[{"content":"毕设替代材料汇总 全部提交材料清单 下载\n最终需提交一份填写好内容的档案袋，里面包含材料1（自行胶装后放入档案袋）与材料2（自行光盘刻录后放入档案袋）。\n材料1（自行胶装后放入档案袋）（已按装订顺序排列） 装订封面、诚信承诺 下载 替代论文（含封面）封面与参考格式下载 毕业论文（设计）过程材料装订封面及目录 下载 佐证材料（如获奖证书、研究报告等） 自行准备 科研项目佐证材料包括：项目申请书，立项通知（文件）、项目结题报告，项目验收证明 替代申请表 档案袋中 答辩记录表 档案袋中 考核表 档案袋中 课程目标达成度表（指导老师4月底给予） 导师提供 空白封底 胶装封底一张白纸 材料2（自行光盘刻录后放入档案袋） 论文替代申请书（之前提交的word即可，无需审核意见等） 相关佐证材料文档（或扫描件） 替代论文文档（含论文封面） 替代论文要求 正文(包括参考文献）小四号宋体 英文 Times New Roman 小四号字 页边距 左3cm，右2.5cm，上下各2.5cm 标准字间距，行距20磅 单面打印 正文页眉内容 杭州电子科技大学本科毕业设计（论文） 正文页码 居中 档案袋填写要求 切记成绩要与考核表内一致\n截止时间 我不知道🤷，尽量5月中下旬完成\n","date":"2025-05-12T14:35:05+08:00","image":"https://cdn.hluvmiku.tech/image/202505121527782.png-small.webp","permalink":"https://hluvmiku.tech/blog/academic-dissertation-materials-summary/","title":"Academic Dissertation Materials Summary"},{"content":" Tip\n通过本文，你将了解：\nMVP变换的基本实现（作业1） Note\nUbuntu安装OpenCV教程将在后续给出。\n前言 最近在备战复试项目，感觉图形学和我比较契合，遂努力速通GAMES101，最好能把202也学一些吧。\n作业1 作业要求实现get_model_matrix与get_projection_matrix,即实现Model矩阵与Projection矩阵。\nModel矩阵实现 Model矩阵实现较为简单，直接给出：\n1 2 3 4 5 6 7 8 9 Eigen::Matrix4f get_model_matrix(float rotation_angle) { Eigen::Matrix4f model = Eigen::Matrix4f::Identity(); model \u0026lt;\u0026lt; std::cos(rotation_angle/180*std::acos(-1)), -std::sin(rotation_angle/180*std::acos(-1)), 0, 0, std::sin(rotation_angle/180*std::acos(-1)), std::cos(rotation_angle/180*std::acos(-1)), 0,0, 0,0,1,0, 0,0,0,1; return model; } Tip\n需注意，对于角度计算，我们需要将rotation_angle从弧度制转化为角度制rotation_angle/180*std::acos(-1)。其中std::acos(-1)=$\\pi$。\nProjection矩阵实现 在实现Projection矩阵之前，我们先回顾一下在进行Projection有关知识点。\nProjection有两种，分别为正交投影(orthogonal projection)与透视投影(prespective projection)。在实际投影过程中，如果是透视投影我们会先通过一个矩阵$M_{presp.\\longrightarrow ortho.}$将透视投影变化为正交投影再按正交投影处理。\n先从一般的正交投影开始讲起，它可以分为平移与缩放两步，$M_{\\text{ortho.}}=S_{\\text{ortho}}\\cdot T_{\\text{ortho}}$,其中有：\n$$ S_{\\text{ortho}} = \\begin{bmatrix} 2/(r-l) \u0026amp; \u0026amp; \u0026amp; \\\\ \u0026amp; 2/(t-b) \u0026amp; \u0026amp; \\\\ \u0026amp; \u0026amp; 2/(n-f) \u0026amp; \\\\ \u0026amp; \u0026amp; \u0026amp; 1 \\end{bmatrix} $$\n$$ T_{\\text{ortho}} = \\begin{bmatrix} 1 \u0026amp; \u0026amp; \u0026amp; -\\frac{(l+r)}{2} \\\\ \u0026amp; 1 \u0026amp; \u0026amp; -\\frac{(t+b)}{2}\\\\ \u0026amp; \u0026amp; 1 \u0026amp; -\\frac{(n+f)}{2}\\\\ \u0026amp; \u0026amp; \u0026amp; 1 \\end{bmatrix} \\sim \\begin{bmatrix} 1 \u0026amp; \u0026amp; \u0026amp; 0 \\\\ \u0026amp; 1 \u0026amp; \u0026amp; 0\\\\ \u0026amp; \u0026amp; 1 \u0026amp; -\\frac{(n+f)}{2}\\\\ \u0026amp; \u0026amp; \u0026amp; 1 \\end{bmatrix}{\\small （相机在原点）} $$\n需要注意的是，我们要先做平移再做放缩。\n接下来是透视投影部分。上文已经讲过，对于透视投影，我们只需要将其转化为正交投影即可，因此，我们只需在$M_{\\text{ortho.}}$右乘一个变换矩阵$M_{\\text{presp.} \\to \\text{ortho.}}$即可。具体推导看视频。\n$$ M_{\\text{presp.} \\to \\text{ortho.}} = \\begin{bmatrix} z_{\\text{near}} \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; z_{\\text{near}} \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; z_{\\text{near}} + z_{\\text{far}} \u0026amp; -z_{\\text{near}} * z_{\\text{far}} \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\end{bmatrix}{\\small （右手系）} $$\nWarning\n在OpenGL中，默认使用左手系，此时需将其改为如下形式：\n$$ M_{\\text{presp.} \\to \\text{ortho.}} = \\begin{bmatrix} z_{\\text{near}} \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; z_{\\text{near}} \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; -z_{\\text{near}} - z_{\\text{far}} \u0026amp; z_{\\text{near}} * z_{\\text{far}} \\\\ 0 \u0026amp; 0 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix}{\\small （左手系）} $$\n在作业2中我们很快就将看到。\n故，我们可以得到代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 Eigen::Matrix4f get_projection_matrix(float eye_fov, float aspect_ratio, float zNear, float zFar) { // Students will implement this function Eigen::Matrix4f projection = Eigen::Matrix4f::Identity(); // TODO: Implement this function // Create the projection matrix for the given parameters. // Then return it. Eigen::Matrix4f M_proj_to_ortho, M_ortho, S_ortho, T_ortho; M_proj_to_ortho \u0026lt;\u0026lt; zNear, 0, 0, 0, 0, zNear, 0, 0, 0, 0, zNear+zFar, -zNear*zFar, 0,0,1,0; float t,r; t = std::abs(zNear * std::tan(eye_fov/180*std::acos(-1) / 2.0f)); float b = -t; r = t * aspect_ratio; float l = -r; // S_ortho \u0026lt;\u0026lt; 1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1; S_ortho \u0026lt;\u0026lt; 2.0f/(r-l),0,0,0, 0,2.0f/(t-b),0,0, 0,0,2.0f/(zNear-zFar),0, 0,0,0,1; T_ortho \u0026lt;\u0026lt; 1,0,0,-(r+l)/2, 0,1,0,-(t+b)/2, 0,0,1,-(zNear+zFar)/2.0f, 0,0,0,1; M_ortho = S_ortho * T_ortho; projection = M_ortho * M_proj_to_ortho; return projection; } 对应完整公式:\n$$ M_{\\text{{proj.}}} = M_{\\text{ortho.}} \\cdot M_{\\text{presp.} \\to \\text{ortho.}} = S_{\\text{ortho.}} \\cdot T_{\\text{ortho.}} \\cdot M_{\\text{presp.} \\to \\text{ortho.}} $$\nNote\n插一句题外话，课程中的思考“z是变近还是变远”，其答案是变远。\n我们假设z距离不变,并计算实际的坐标，有： $$ P_{\\text {assume}} = \\begin{bmatrix} zx \\\\ zy \\\\ z^2 \\\\ z \\end{bmatrix}, P_{\\text {real}} = \\begin{bmatrix} z_{near}x \\\\ z_{near}y \\\\ z*(z_{near}+z_{far})-z_{near}*z_{far} \\\\ z \\end{bmatrix} $$ 对assume和real的z坐标进行联立，可得$z_1=z_{\\text{near}}, z_2=z_{\\text{far}}$,在区间中，实际坐标大于假设（不变）。\n作业1提高项部分过于简单，故不在此提供。\n结语 作业1属于热身性质，别忘了概念就行。\n","date":"2025-02-18T23:01:14+08:00","image":"https://cdn.hluvmiku.tech/image/202502190107765.png-small.webp","permalink":"https://hluvmiku.tech/blog/games-101-assignment-1/","title":"Games 101 Assignment 1"},{"content":" Tip\n通过本文，你将了解：\n如何更方便的使用Li4n0/hugo_encryptor \u0026ldquo;PY_SSIZE_T_CLEAN macro must be defined for \u0026lsquo;#\u0026rsquo; formats\u0026rdquo; 报错的解决方法 简易修改 Note\n建议先参考本文利用Github Action将博客部署到Github Page上获得最佳体验。\n前言 博客偶尔想放些涉及个人生活比较深入的东西，但又只希望与接触比较深的人或者部分相关人士查看。这种情况下设置个大家心知肚明的密码最好。\n原理 简单来说，hugo-encryptor加密流程如下：\n利用shortcode渲染待加密内容 用一段python程序对渲染结果（/public文件夹下所有文件）进行匹配，加密待加密内容 部署 因此，如果只是配置了shortcode而没有运行加密程序的话，文章内容不会被加密。而具体配置过程也因此分成了配置主题、配置部署两部分。 为主题引入hugo_encryptor 原作者给出的办法个人感觉不是很好看：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ### Step 1: Install all the requirements of Hugo-Encryptor $ git clone https://github.com/Li4n0/hugo_encryptor.git $ cd hugo_encryptor $ chmod +x hugo-encryptor.py $ pip install -r requirements.txt ### Step 2: Create a symlink (Optional) $ ln -s /absolute/path/to/hugo_encryptor/hugo-encryptor.py hugo-encryptor.py ### Step 3: Symlink `shortcodes/hugo-encryptor.html` into the shortcode directory of your blog: $ mkdir -p /path/to/your/blog/layouts/shortcodes $ ln -s /absolute/path/to/hugo_encryptor/shortcodes/hugo-encryptor.html /path/to/your/blog/layouts/shortcodes/hugo-encryptor.html 我更倾向于将其直接放入主题中去，我的方法如下：\n找到主题对应的layouts/partials/shortcodes文件夹，在里面新建一个文件夹hugo-encryptor.html。\n将以下代码复制粘贴入其中： 点击查看代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 {{ $_hugo_config := `{ \u0026#34;version\u0026#34;: 1 }` }} {{/* ## Hugo Encrypt ### Params: - `password`： require param - Simple \u0026lt;div class=\u0026#34;hugo-encryptor-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;hugo-encryptor-prompt\u0026#34;\u0026gt; \u0026lt;p\u0026gt;文章的部分内容被密码保护：\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;hugo-encryptor-form\u0026#34;\u0026gt; \u0026lt;input class=\u0026#34;hugo-encryptor-input\u0026#34; placeholder=\u0026#39;请输入密码\u0026#39; /\u0026gt; \u0026lt;input class=\u0026#34;hugo-encryptor-button\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#39;点击验证\u0026#39; onclick=\u0026#34;_click_handler(this)\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;hugo-encryptor-cipher-text\u0026#34; data-password=\u0026#34;your password\u0026#34; style=\u0026#34;display: none;\u0026#34; \u0026gt; \u0026lt;span style=\u0026#34;display: none;\u0026#34;\u0026gt;--- DON\u0026#39;T MODIFY THIS LINE ---\u0026lt;/span\u0026gt; \u0026lt;p\u0026gt;your content\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; */}} {{/* DEFAULTS */}} \u0026lt;div class=\u0026#34;hugo-encryptor-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;hugo-encryptor-prompt\u0026#34;\u0026gt; {{ if eq .Site.Params.hugoEncryptorLanguage \u0026#34;en-us\u0026#34; }} \u0026lt;p\u0026gt;Part of this article is encrypted with password:\u0026lt;/p\u0026gt; {{ else }} \u0026lt;p\u0026gt;文章的部分内容被密码保护：\u0026lt;/p\u0026gt; {{ end }} \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;hugo-encryptor-form\u0026#34;\u0026gt; \u0026lt;input class=\u0026#34;hugo-encryptor-input\u0026#34; placeholder=\u0026#39;{{ if eq .Site.Params.hugoEncryptorLanguage \u0026#34;en-us\u0026#34; }}Please input the password{{ else }}请输入密码{{ end }}\u0026#39; /\u0026gt; \u0026lt;input class=\u0026#34;hugo-encryptor-button\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#39;{{ if eq .Site.Params.hugoEncryptorLanguage \u0026#34;en-us\u0026#34; }}Click to verify{{ else }}点击验证{{ end }}\u0026#39; onclick=\u0026#34;_click_handler(this)\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;hugo-encryptor-cipher-text\u0026#34; data-password=\u0026#34;{{ .Get 0 }}\u0026#34; style=\u0026#34;display: none;\u0026#34; \u0026gt; \u0026lt;span style=\u0026#34;display: none;\u0026#34;\u0026gt;--- DON\u0026#39;T MODIFY THIS LINE ---\u0026lt;/span\u0026gt; {{ .Inner }} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 找到主题对应header部分的模板，在其末尾添加： 点击查看代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const _do_decrypt = function (encrypted, password) { let key = CryptoJS.enc.Utf8.parse(password); let iv = CryptoJS.enc.Utf8.parse(password.substr(16)); let decrypted_data = CryptoJS.AES.decrypt(encrypted, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }); return decrypted_data.toString(CryptoJS.enc.Utf8); }; const _click_handler = function (element) { let parent = element.parentNode.parentNode; let encrypted = parent.querySelector( \u0026#34;.hugo-encryptor-cipher-text\u0026#34;).innerText; let password = parent.querySelector( \u0026#34;.hugo-encryptor-input\u0026#34;).value; password = CryptoJS.MD5(password).toString(); let index = -1; let elements = document.querySelectorAll( \u0026#34;.hugo-encryptor-container\u0026#34;); for (index = 0; index \u0026lt; elements.length; ++index) { if (elements[index].isSameNode(parent)) { break; } } let decrypted = \u0026#34;\u0026#34;; try { decrypted = _do_decrypt(encrypted, password); } catch (err) { console.error(err); alert(\u0026#34;Failed to decrypt.\u0026#34;); return; } if (!decrypted.includes(\u0026#34;--- DON\u0026#39;T MODIFY THIS LINE ---\u0026#34;)) { alert(\u0026#34;Incorrect password.\u0026#34;); return; } let storage = localStorage; let key = location.pathname + \u0026#34;.password.\u0026#34; + index; storage.setItem(key, password); parent.innerHTML = decrypted; } window.onload = () =\u0026gt; { let index = -1; let elements = document.querySelectorAll( \u0026#34;.hugo-encryptor-container\u0026#34;); while (1) { ++index; let key = location.pathname + \u0026#34;.password.\u0026#34; + index; let password = localStorage.getItem(key); if (!password) { break; } else { console.log(\u0026#34;Found password for part \u0026#34; + index); let parent = elements[index]; let encrypted = parent.querySelector(\u0026#34;.hugo-encryptor-cipher-text\u0026#34;).innerText; let decrypted = _do_decrypt(encrypted, password); elements[index].innerHTML = decrypted; } } }; \u0026lt;/script\u0026gt; Warning\n请注意，此时文章还未被加密，需完成python的配置才行。\n即可完成主题部分的配置。\n配置部署 Note\n建议先参考本文利用Github Action将博客部署到Github Page上获得最佳体验。本地运行属实麻烦，下文假设你使用Github Action将博客部署到Github Page上。\n我们再回顾一下hugo-encryptor的工作原理：\n利用shortcode渲染待加密内容 用一段python程序对渲染结果（/public文件夹下所有文件）进行匹配，加密待加密内容 部署 在上一小节中，我们已经实现了1. 利用shortcode渲染待加密内容，而由于我们使用Github Action，我们可以将23两步结合起来，实现全自动加密，避免忘记运行加密程序导致隐私泄漏。\n步骤如下：\n在博客仓库创建一个文件夹hugo_encryptor,将Li4n0/hugo_encryptor中的hugo-encryptor.py与requirements.txt放入其中。 对原有的部署工作流如此修改： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ... env: ... HUGO_ENCRYPTOR_PATH: ./hugo_encryptor ... jobs: build: steps: ... - uses: actions/setup-python@v4 with: python-version: \u0026#39;3.9\u0026#39; - name: Install Python and Dependencies run: | sudo apt-get update sudo apt-get install -y python3 python3-pip pip3 install -r ${{ env.HUGO_ENCRYPTOR_PATH }}/requirement.txt - name: Build Hugo site run: hugo --minify --gc - name: Encrypt private posts run: | python3 ${{ env.HUGO_ENCRYPTOR_PATH }}/hugo-encryptor.py env: HUGO_ENCRYPTOR_PATH: ./hugo_encryptor # Adjust this path based on where your `hugo_encryptor.py` script is located ... 其中，python版本选择3.9最佳，3.10及以上会报错：PY_SSIZE_T_CLEAN macro must be defined for '#' formats。此时可以选择以下两种做法：\n回退3.9版本python（推荐） 重新用pip卸载再安装pycryptodome库 至此，基本配置结束。 参考workflow 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 name: Deploy Hugo site to Pages on: # Runs on pushes targeting the default branch workflow_dispatch: push: branches: [\u0026#34;master\u0026#34;] # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages permissions: contents: read pages: write id-token: write # Environment variables available to all jobs and steps in this workflow env: HUGO_ENV: production HUGO_VERSION: \u0026#34;0.115.4\u0026#34; GO_VERSION: \u0026#34;1.20.5\u0026#34; NODE_VERSION: \u0026#34;18.15.0\u0026#34; TINA_CLIENT_ID: ${{ vars.TINA_CLIENT_ID }} TINA_TOKEN: ${{ vars.TINA_TOKEN }} HUGO_ENCRYPTOR_PATH: ./hugo_encryptor jobs: build: runs-on: ubuntu-latest permissions: contents: write # Allow write access to commit changes to the repository steps: - uses: actions/checkout@v4 with: submodules: \u0026#39;recursive\u0026#39; - name: Cache Hugo resources uses: actions/cache@v4 env: cache-name: cache-hugo-resources with: path: resources key: ${{ env.cache-name }} - uses: actions/setup-go@v5 with: go-version: \u0026#34;^1.17.0\u0026#34; - run: go version - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - uses: actions/setup-python@v4 with: python-version: \u0026#39;3.9\u0026#39; - name: Install Python and Dependencies run: | sudo apt-get update sudo apt-get install -y python3 python3-pip pip3 install -r ${{ env.HUGO_ENCRYPTOR_PATH }}/requirement.txt - name: Build Hugo site run: hugo --minify --gc - name: Encrypt private posts run: | python3 ${{ env.HUGO_ENCRYPTOR_PATH }}/hugo-encryptor.py env: HUGO_ENCRYPTOR_PATH: ./hugo_encryptor # Adjust this path based on where your `hugo_encryptor.py` script is located - name: Upload artifact uses: actions/upload-pages-artifact@v1 with: path: ./public - name: Echo CNAME run: echo ${{ secrets.CNAME }} \u0026gt; ./public/CNAME - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} EXTERNAL_REPOSITORY: HaleyCH/HaleyCH.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} 为encryptor添加密码提示 为了让目标受众知道我设置的密码是什么，有必要增加密码提示功能，这比较简单，只需将\n1 2 3 {{ else }} \u0026lt;p\u0026gt;文章的部分内容被密码保护：\u0026lt;/p\u0026gt; {{ end }} 改为\n1 2 3 {{ else }} \u0026lt;p\u0026gt;文章的部分内容被密码保护{{ if .Get 1 }}，提示 “{{ .Get 1 }}”{{ end }}：\u0026lt;/p\u0026gt; {{ end }} 即可。最终成果如下所示（密码hugo）。\n文章的部分内容被密码保护，提示 “此博客用的框架”：\n--- DON'T MODIFY THIS LINE --- 对，就是hugo。\n至此，我们完成了hugo-encryptor的配置与简单修改。 ","date":"2024-12-24T00:41:07+08:00","image":"https://cdn.hluvmiku.tech/image/202412240151573.png-small.webp","permalink":"https://hluvmiku.tech/blog/encrypt-your-article-in-hugo/","title":"Encrypt Your Article in Hugo"},{"content":" 文章的部分内容被密码保护，提示 “我的名字全拼小写”：\n--- DON'T MODIFY THIS LINE --- 阶段性总结-2024.11.30 上次总结还是2023年年度总结。\n就说说考研吧 去年年度总结时我说：\n明年3月前不搞出论文的话就认真考研了。\n确实是一语成谶，在那之后多少有点道心破碎。就随便摆摆烂带了几个比赛就开始备考考研了。\n3、4月份非常认真有干劲，5、6月份开始疲软。7-9月在和张宇强化36讲鏖战，10、11两个月在赶进度。总体上说感觉进度慢了一个月，大概是我把太多精力放在数学上了（也不见得就考得好）。最近意识到数一多拿5分没408英语政治多保几分来的方便，开始转移重心。\n我应该学的还蛮认真的，怎么就进度这么慢呢？\n或许是起步晚了。 眼见着还有22天就考试了，我还有好多地方都还没解决：\n高数、线代常见公式、结论背诵 概率论结论背诵 英语刷题 英语翻译、作文 政治肖四肖八时政 408二轮 问题最大的是408二轮还没结束，英语真题和词汇也被我搁置太久了，如果初试没过，大抵就是这两门害的。\n挺多思想上的转变我想留到年度总结里写，就先不写了 哦昨天学生会团建，几十天没社交我居然还能玩挺自在，指不定我也不是那么的不爱社交？大概\n下午还要和张宇搏斗，就写到这里，午睡要紧。\n2024.11.30中午，写于杭电图书馆二楼西85座\n","date":"2024-12-24T00:28:12+08:00","permalink":"https://hluvmiku.tech/blog/stage-summary-2024/11/30/","title":"Stage Summary 2024/11/30"},{"content":"这一次主打光影+线条。\n算是对自己审美构图后期的测试。\n","date":"2024-05-19T16:20:10+08:00","image":"https://cdn.hluvmiku.tech/image/image202405191618669.jpg-small.webp","permalink":"https://hluvmiku.tech/blog/iphone-street-snap-hangzhou-city-park/","title":"iPhone Street Snap - HangZhou City Park"},{"content":" Note\n前面有好多废话，可以直接无视。\n为了你\n失去你\n狠心扮演伤害你😭\n― 阿木, 有一种爱叫做放手，Apple Music AirPods Max就音质和外观来说，都是十分优秀的。\n但由于诸多本人实际体验上的不便，我还是放弃了它。\n终于，我购入了镌刻的AirPods Max 选择购入AirPods Max经历了一个漫长的过程。\n早在购买前很久，我就发表过如下言论：\n如果不是入了苹果生态，我绝对不会推荐买AirPods。\n确实如此，可以说AirPods Max的购买史见证了我一步步进入苹果生态。\n我的“去索尼化”经历 谈到耳机，毫无疑问，索尼的耳机一直是备受青睐的明星产品。\n在购入AirPods系列前，我有三副耳机：Sony WF1000-XM3入耳式无线降噪耳机、Sony WF1000-XM4入耳式无线降噪耳机、Sony WH1000-XM4头戴式无线降噪耳机。\n也不是说我是索粉吧，但是比较主流的索尼无线降噪耳机我都还是使用了蛮久的。\n他们有什么问题吗？个人感觉除了只能最多同时连接两台设备不是很舒服以外，完全没有。\n但是我还是放弃了索尼耳机。为什么？\n这就得从一个iPad说起了。 大一上，我就购入了一个iPad。\n这是我第一次意识到原来苹果是这么优秀的厂商。这也为我之后进入苹果生态打下了基础。\n优秀的交互体验、与用户的“契约意识”、对细节极致到变态的追求、优美的工业设计理念、创新的产品思维。\n这是我对苹果的评价。\n其中尤其是对细节极致到变态的追求与我的许多想法理念一拍即合，这使得我迅速爱上了苹果。\n忍不了，换个AirPods Pro2 大二，忍受不了游戏本糟糕的续航，再加上对苹果的喜爱，我换下了我的G15和三星S21，购入了一台MacBook M1 Pro和一个iPhone 13。\n至此，我都还在用我的索尼耳机\n之前也有提到，我感觉：\n只能最多同时连接两台设备不是很舒服\n尤其是当时，我有一台Windows、一台mbp、一个iPhone、一个iPad，耳机连来连去确实太麻烦了，忽闻Type C的AirPods Pro2发售了。\n仔细一看，😯，居然能支持在设备间无缝切换！\n再考虑到我佩戴索尼入耳式耳机跑步时它容易滑落（无端找换耳机理由），当机立断，我购入了一个AirPods Pro2。\n无缝切换真的很舒服 使用下来，确实舒服啊。\n平时学习搞科研写代码，一般是iPad和Mac。\n一天工作结束，回生活区路上它能自动切换到iPhone的声音而不需要手动连接蓝牙，跑步时，它也能方便的与Apple Watch配对。可以说，它在苹果生态里如鱼得水，超级丝滑。\n此时，还有一个Sony WH1000-XM4头戴式无线降噪耳机在我手中，我是看它越来越不爽啊，有线连一个，无线连一个（还是两个，忘了），每次用它都要点来点去，颇为麻烦。\n考虑到我现在已经完全进入苹果生态，我决定购入一个AirPods Max来替代它。\n当然在购买之前，我还是犹豫了很久，期间把WH1000-XM4卖了，换过Beats solo 3。这玩意是真的糟糕，除了好看一无是处。 AirPods Max，实际佩戴使用与店内体验差别巨大🤯 非常快，下单完两天后，耳机就到手了。我甚至还定制了镌刻。 迫不及待的，我带着它就去考研复习了。\n但是经过短短的几个小时的佩戴，我就意识到这耳机有大问题。\n脖子好酸 在看了一个小时的张宇考研以后，我十分清晰的感觉到脖子发酸。\n我暂停视频思考了下，是不是我今天坐姿不对。\n想了一会才意识到，我今天带的不是轻便无感的AirPods pro2，而是重达6个鸡蛋的AirPods Max。\n头顶6个鸡蛋看视频，想想就累。\n但我想想，指不定是我脖子肌肉锻炼不够呢？多戴戴就好了。\n不经让我想起了：\n为什么说苹果用户的自适应能力强？\n― 知乎用户提问 夹的好疼 忍着脖子的酸痛继续复习🥷\n又学了一会，我坐不住了。\n真的好疼好疼！太久没带头戴式耳机让我忘了很关键的一点：\n头戴式耳机会压眼睛腿\n确实非常疼，就这么说吧，我忍着痛带了一天耳机，之后到退款为止，再也没敢戴它。\n其实在买之前，我是有比较过参数的，AirPods Max的压力和Sony WH1000-XM4是差不多的。\n但是我却忽略了一点，AirPods Max用的是织物耳罩，比WH1000-XM4硬了不只一点亮点（虽然织物耳罩佩戴体验真的非常舒适）。这就使得在同等压力的情况下，AirPods Max会更加使眼镜腿压迫我的头。 看看这个细的要死的眼镜腿，配合AirPods Max一套组合技压的我头疼死了，已经过了4天我还是感觉被压的地方隐隐作痛，大抵是肿了。\n猝不及防的忍“痛”退款 经过一天佩戴，我已经意识到，这耳机可能不适合我。\n于是我想看看能不能退款，给自己留个退路。\n这是我第一次退款，在图书款忍着头痛，随便在Apple Store点了几下就没管了。\n莫名收到退款短信 然而20分钟后，Apple给我发短信说我的退款已经被受理。\n我：？？？\n本来我还想试着用东西给耳机撑开，减轻下压力看看能不能舒服点。\n这下倒好，直接给我退了。\n我仔细找了找，发现这退款流程还不能取消（话说如果不给快递员的话，指不定可以不退。\n所以退款一定要注意（尤其是在货还没到快递站的时候） 在货还没到快递站的时候，千万不要点退货！\n如果手贱点几下，得，启动退货流程，不能取消。\n直接给你物流拦截返厂一气呵成。\n退款流程 半是无奈半是窃喜（省下一笔钱）的接受了不能取消退款的事实后，我开始研究该退款细节。\n苹果退款非常人性化。只需要你把所有东西放回原包装，写上退款订单号就好了。\n苹果会联系快递员来取货。\n啥都不用你管\n总结 老实说，在使用了一天AirPods Max之后，再用pro2听歌总感觉有点廉价的塑料感。所以实际上它音质还是很好的。降噪也是。\n任何一款耳机都不可能适合所有人群，但凡我眼镜腿再粗一点，我也就还能接受它了。\n为了避免我对它主观印象变得太差（已经被夹疼出心理阴影了），我选择了退货。\n文笔不好，本来想先说说为什么推荐且只推荐苹果生态入AirPods系列产品，再讲讲我的具体事例，然后讲AirPods Max的亮点，接下来讲和我预期不符的地方。之后再陈述出他对于不戴眼镜的苹果生态的人还是蛮友善的，最后比较一下。\n但是我只有一个小时时间，列了个大纲就开始码字了，好多地方没写到😭。吃个饭复习考研。\n","date":"2024-05-14T16:14:38+08:00","image":"https://cdn.hluvmiku.tech/image/image202405141717909.heic","permalink":"https://hluvmiku.tech/blog/airpods-maxwhy-i-opted-a-refund/","title":"AirPods Max:Why I Opted a Refund"},{"content":"说“新”也不新，换个主题更好看 考研着实累，周末换个口味。 于是想到把博客翻新一下。\n之前本着干净简洁的原则，用的是hugoplate主题，可是用到后来越发觉得不舒服，杂七杂八插件一堆，还用了很多第三方库。 这着实是有点违背我的初衷。\n本来长这样\n随便找找，就看到了这个stack主题。 暴力改造了一个晚上，终于是给它迁移到这个主题了。\n本来就是杂谈，也没干货，就水到这里了。\n最近折腾了下群晖NAS的IPv6的DDNS，顺带研究了下Surge的配置文件和subconverter。\n还买了个AirPods Max，但是因为夹耳朵又退了。\n学生会也快换届了，全媒体有四个人留部长（说是这么说），挺好的。\n说说考研吧 在复习，感觉效率还是低\n总是有杂七杂八的事情，另一方面我个人还总是收不住心\n高数基础快过完了，还有线代离散。\n英语单词背的着实有点慢。\n408也还是刚起步。\n还是慢啊。\n","date":"2024-05-12T23:51:04+08:00","permalink":"https://hluvmiku.tech/blog/again-a-new-blog/","title":"Again a New Blog"},{"content":" Tip\n不定期更新 上次更新时间：2024-04-18\nNote\n本壁纸尺寸仅适配了iPhone13/14数字系列。\n部分考研壁纸分享 考研壁纸下载 （推荐使用）考研壁纸-百度网盘，提取码hluv，最后更新于2024-04-18\n考研壁纸-figma项目，实时更新\n考研壁纸，与其他考研资料-美区icloud链接，实时更新\n（备份下载）考研壁纸-本站下载，最后更新与于2024-04-18\n","date":"2024-04-18T11:22:05+08:00","image":"https://cdn.hluvmiku.tech/image/image202404181135472.png-small.webp","permalink":"https://hluvmiku.tech/blog/postgraduate-exam-wallpaper/","title":"Postgraduate Exam Wallpaper"},{"content":" 文章的部分内容被密码保护，提示 “我的名字全拼小写”：\n--- DON'T MODIFY THIS LINE --- 老实说按年来总结挺难的，挺多事情挺没条理的。\n图文回顾 2月：\n换MacBook和iPhone 3月： 部门聚餐+定位抓人 给彪彪过生日 铃芽之旅\n小解源源表情包\nIT科技文化月筹备\n4月：\n扫墓\n时光之书主视觉\n生日\n5月：\nGPT4 API通过 时光之书举办\n王国之泪 部门散伙饭\n6月：\n服务外包初赛 夫子庙、eva、南京大排档、美术馆\n购入switch 7月：\n夏令营助教 购入健身环\n8月：\n服务外包复赛\n更新桌面布局\n高中同学聚餐 学院迎新、学生会招新\n9月：\n买到假beats\n10月：\n院学生会主席聘书 11月、12月：\n迎新晚会 疲于奔命 怎么说呢，很多时间疲于奔命，但是空闲时间也被我浪费了很多。\n不如大一大二自律了，可能是因为有点累。\n人际关系也有所更新，有触碰我底线的慢慢淡出交际圈，也有有能力的人进入交际圈，挺好的。\n就是有点可惜，还是没遇到让我心动的人，大概有能力和我处的舒服的人和我一样都喜欢宅在家里。\n学生会的事情慢慢放下了，今年不知道为什么招新质量比较差，小解没留任也让我学生会计划大乱。\n学术上的话，前面的就不说了，12月26号清华和哈佛发了一篇论文，把我的方向给撞死了。\n挺遗憾的说实话，思路架构出发点和绝大多数的小细节，我都和那篇论文一致。\n我一开始做这个方向的思路就是用一个autoencoder对语义空间压缩，但是遗憾的是我没投入太多时间在这上面，否则谁先搞出来还真不一定。\n现在估计就只能随便在预处理的pipeline稍微改改水一下了。\n明年3月前不搞出论文的话就认真考研了。\n琐事总算写完了。\n今年变化是挺大的。\n首先呢感觉我又变宅回去了，其次在我明白我没必要对所有人上心后，我活着也自在了。\n抛开的一些高中同学之间社交也在慢慢捡回来，很好。\n也开始渐渐对婚姻市场感到不自在了。\n早就下定了决心，只对自己和家人好一些，最多再加上一位以后会长期在一起的人。 很庆幸周围有很多I人朋友，和E人交流真的很疲惫。\n","date":"2023-12-30T23:18:43+08:00","image":"https://cdn.hluvmiku.tech/image/image202402271541817.png","permalink":"https://hluvmiku.tech/blog/year-end-summary-2023/12/30/","title":"Year End Summary 2023/12/30"},{"content":" Tip\n通过本文，你将了解：\nFLex基本操作 如何通过FLex编写一个简单的词法分析器 Note\n此词法分析器将作为一个语法分析器的部分，因此输出仅为一系列的Token与值，并不执行其他操作。\n此外，本词法分析器基于SysY语法，它是c语言的一个子集。\n本文将收录于杭电编译原理实验报告\n前言 GNU FLex 介绍 点击查看FLex介绍 Flex的前身是Lex。Lex是1975年由Mike Lesk和当时还在AT\u0026amp;T做暑期实习的Eric Schmidt，共同完成的一款基 于Unix环境的词法分析程序生成工具。虽然Lex很出名并被广泛 使用，但它的低效和诸多问题也使其颇受诟病。后 来伯克利实验室的Vern Paxson使用C语言 重写Lex，并将这个新的程序命名为Flex(意为Fast Lexical Analyzer Generator)。无论在效 率上还是在稳定性上，Flex都远远好于它的前辈Lex。我们在Linux下使用的是Flex在GNU License下的版本，称作GNU Flex。\nFLex安装与初步使用 在Linux中，安装FLex十分简单，只需要sudo apt-get install flex即可。\n然后我们创建一个新文件scanner.l，并在其中输入以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 %% [0-9]+ printf(\u0026#34;?\u0026#34;); # return 0; . ECHO; %% int main(int argc, char* argv[]) { yylex(); return 0; } int yywrap() { return 1; } 使用指令flex scanner.l编译程序，可以看到目录下出现了一个名为 lex.yy.c的文件，我们再使用gcc -o scanner lex.yy.c，即可得到可执行文件./scanner。\n我们试着运行一下./scanner并输入：\n1 2 3 4 5 6 7 $ ./scanner afeafewa afeafewa 1233 ? aaaa111 aaaa? 可以观察到这段代码将数字部分都替换为了?，其他部分不变。\nFLex语法浅析 在介绍FLex语法前，先解释上文程序工作原理。\n观察代码，可以看到[0-9]+ printf(\u0026quot;?\u0026quot;);，这行代码匹配输入中包含1个或多个数字，接收到数字串后输出一个?。\n程序执行时，逐字读取输入，并自上而下尝试匹配定义的规则，并执行匹配规则后方的代码。\n在本程序中，如果是数字，会被[0-9]+匹配，并输出?，而其它字符将被. ECHO;匹配，输出该字符本身。因此上文的代码才能实现将数字部分都替换为了?，其他部分不变的功能。\nFLex语法可以分为三部分：\n1 2 3 4 5 {definitions} %% {rules} %% {user subroutines} 其中definitions部分定义了一系列别名，格式为name definitions。例如br [ \\t]+就是定义br为连续的一个或多个空格或制表符，在rules中，直接可以使用br代替[ \\t]+进行匹配。\n这就使规则定义更加灵活，例如：\n1 2 3 identifier {identifier-nondigit}({identifier-nondigit}|{identifier-digit})* identifier-digit [0-9] identifier-nondigit [_a-zA-Z] 这就定义了一个identifier应该有的格式：一个非数字符号开头、有0个或多个字符、下划线重复组成的字符串。\nrules部分格式为re/name actions，例如[0-9]+ printf(\u0026quot;?\u0026quot;);，FLex将自上而下对输入字符进行匹配，并执行对应的代码。\n而user subroutines将会被原封不动的复制进入lex.yy.c中，你可以在这里定义一系列自定义函数与main函数。\nSysY介绍 你可以在此处找到详细的SysY 2022文法的定义。\n实现 Note\n完整代码在完整代码小节中。\n词法分析器接收字符串组序列，输出字符符号序列并识别可能的词法错误，将其交给语法分析器。\n因此，我们在词法分析部分只需简单的用正则表达式匹配字符集中的各种模式和关键词即可。\n由于FLex是自上而下匹配，因此我们可以在末尾使用.通配符匹配所有未在符号集中的单词，并抛出词法错误。\n并且，因为我们还未接入语法分析器（语法分析器部分将收录于编译原理实验四），我们只需简单的打印匹配结果验证词法分析结果即可。\ndefinitions部分 1 2 3 4 identifier {identifier-nondigit}({identifier-nondigit}|{identifier-digit})* identifier-digit [0-9] identifier-nondigit [_a-zA-Z] br [ \\t]+ rules部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 {br} {;} \u0026#34;/\\*\u0026#34; { char curr,prev; prev = \u0026#39;\\0\u0026#39;; curr = input(); while(prev!=\u0026#39;*\u0026#39;||curr!=\u0026#39;/\u0026#39;) {prev = curr; curr = input();} } \u0026#34;//\u0026#34; { printf(\u0026#34;\u0026lt;COMMENT\u0026gt;\\n\u0026#34;); char curr; curr = input(); while(curr!=\u0026#39;\\n\u0026#39;) curr = input(); } \u0026#34;int\u0026#34; {printf(\u0026#34;\u0026lt;INT\u0026gt;\\n\u0026#34;);} /* 省略部分匹配代码，可在完整代码中查看 */ \u0026#34;}\u0026#34; {printf(\u0026#34;\u0026lt;}\u0026gt;\\n\u0026#34;);} \\n { ++yylineno; } \u0026#34;0\u0026#34;[0-9a-zA-Z]* { int pos = 1; char c,buf[2]; c = yytext[pos++]; if (c!=\u0026#39;x\u0026#39;\u0026amp;\u0026amp;c!=\u0026#39;X\u0026#39;){ int total=0; /* 省略部分进制转换代码，可在完整代码中查看 */ } {identifier} {return IDENTIFIER;} [0-9]+ {printf(\u0026#34;\u0026lt;INTNUM, %d\u0026gt;\\n\u0026#34;,atoi(yytext));} . { printf(\u0026#34;Error at Line %d: Invalid characters \\\u0026#39;%s\\\u0026#39;\\n\u0026#34;, yylineno, yytext); } 可以看到，对于大部分内容，仅仅是简单的匹配并输出，而对于整型数字，则需要将其解析为10进制值并输出。\n值得注意的是，为了实现词法分析以及之后工作的结果与行号对应，我们在匹配到回车符时将yylineno加一\\n { ++yylineno; }。yylineno是FLex定义的一个全局变量，代表当前处理行号。\nuser subrouting部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int main(int argc, char** argv) { if (argc \u0026gt; 1) { yyin = fopen(argv[1], \u0026#34;r\u0026#34;); if (!yyin) { perror(\u0026#34;Error opening file\u0026#34;); return 1; } } else { printf(\u0026#34;Usage: %s \u0026lt;filename\u0026gt;\\n\u0026#34;, argv[0]); return 1; } while (yylex() != 0); fclose(yyin); return 0; } int yywrap() { return 1; } 这部分实现了从文件读取代码。\n完整代码 点击此处查看完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 identifier {identifier-nondigit}({identifier-nondigit}|{identifier-digit})* identifier-digit [0-9] identifier-nondigit [_a-zA-Z] br [ \\t]+ %% {br} {;} \u0026#34;/\\*\u0026#34; { printf(\u0026#34;\u0026lt;COMMENT\u0026gt;\\n\u0026#34;); char curr,prev; prev = \u0026#39;\\0\u0026#39;; curr = input(); while(prev!=\u0026#39;*\u0026#39;||curr!=\u0026#39;/\u0026#39;) {prev = curr; curr = input();} } \u0026#34;//\u0026#34; { printf(\u0026#34;\u0026lt;COMMENT\u0026gt;\\n\u0026#34;); char curr; curr = input(); while(curr!=\u0026#39;\\n\u0026#39;) curr = input(); } \u0026#34;int\u0026#34; {printf(\u0026#34;\u0026lt;INT\u0026gt;\\n\u0026#34;);} \u0026#34;float\u0026#34; {printf(\u0026#34;\u0026lt;FLOAT\u0026gt;\\n\u0026#34;);} \u0026#34;void\u0026#34; {printf(\u0026#34;\u0026lt;VOID\u0026gt;\\n\u0026#34;);} \u0026#34;if\u0026#34; {printf(\u0026#34;\u0026lt;IF\u0026gt;\\n\u0026#34;);} \u0026#34;else\u0026#34; {printf(\u0026#34;\u0026lt;ELSE\u0026gt;\\n\u0026#34;);} \u0026#34;while\u0026#34; {printf(\u0026#34;\u0026lt;WHILE\u0026gt;\\n\u0026#34;);} \u0026#34;break\u0026#34; {printf(\u0026#34;\u0026lt;BREAK\u0026gt;\\n\u0026#34;);} \u0026#34;return\u0026#34; {printf(\u0026#34;\u0026lt;RETURN\u0026gt;\\n\u0026#34;);} \u0026#34;+\u0026#34; {printf(\u0026#34;\u0026lt;ADD\u0026gt;\\n\u0026#34;);} \u0026#34;-\u0026#34; {printf(\u0026#34;\u0026lt;SUB\u0026gt;\\n\u0026#34;);} \u0026#34;*\u0026#34; {printf(\u0026#34;\u0026lt;MUL\u0026gt;\\n\u0026#34;);} \u0026#34;/\u0026#34; {printf(\u0026#34;\u0026lt;DIV\u0026gt;\\n\u0026#34;);} \u0026#34;%\u0026#34; {printf(\u0026#34;\u0026lt;MOD\u0026gt;\\n\u0026#34;);} \u0026#34;!\u0026#34; {printf(\u0026#34;\u0026lt;NOT\u0026gt;\\n\u0026#34;);} \u0026#34;,\u0026#34; {printf(\u0026#34;\u0026lt;,\u0026gt;\\n\u0026#34;);} \u0026#34;=\u0026#34; {printf(\u0026#34;\u0026lt;=\u0026gt;\\n\u0026#34;);} \u0026#34;;\u0026#34; {printf(\u0026#34;\u0026lt;;\u0026gt;\\n\u0026#34;);} \u0026#34;\u0026gt;=\u0026#34; {printf(\u0026#34;\u0026lt;GE\u0026gt;\\n\u0026#34;);} \u0026#34;\u0026lt;=\u0026#34; {printf(\u0026#34;\u0026lt;LE\u0026gt;\\n\u0026#34;);} \u0026#34;==\u0026#34; {printf(\u0026#34;\u0026lt;EQ\u0026gt;\\n\u0026#34;);} \u0026#34;!=\u0026#34; {printf(\u0026#34;\u0026lt;NE\u0026gt;\\n\u0026#34;);} \u0026#34;\u0026gt;\u0026#34; {printf(\u0026#34;\u0026lt;GT\u0026gt;\\n\u0026#34;);} \u0026#34;\u0026lt;\u0026#34; {printf(\u0026#34;\u0026lt;LT\u0026gt;\\n\u0026#34;);} \u0026#34;||\u0026#34; {printf(\u0026#34;\u0026lt;OR\u0026gt;\\n\u0026#34;);} \u0026#34;\u0026amp;\u0026amp;\u0026#34; {printf(\u0026#34;\u0026lt;AND\u0026gt;\\n\u0026#34;);} \u0026#34;(\u0026#34; {printf(\u0026#34;\u0026lt;(\u0026gt;\\n\u0026#34;);} \u0026#34;)\u0026#34; {printf(\u0026#34;\u0026lt;)\u0026gt;\\n\u0026#34;);} \u0026#34;[\u0026#34; {printf(\u0026#34;\u0026lt;[\u0026gt;\\n\u0026#34;);} \u0026#34;]\u0026#34; {printf(\u0026#34;\u0026lt;]\u0026gt;\\n\u0026#34;);} \u0026#34;{\u0026#34; {printf(\u0026#34;\u0026lt;{\u0026gt;\\n\u0026#34;);} \u0026#34;}\u0026#34; {printf(\u0026#34;\u0026lt;}\u0026gt;\\n\u0026#34;);} \\n { ++yylineno; } \u0026#34;0\u0026#34;[0-9a-zA-Z]* { int pos = 1; char c,buf[2]; c = yytext[pos++]; if (c!=\u0026#39;x\u0026#39;\u0026amp;\u0026amp;c!=\u0026#39;X\u0026#39;){ int total=0; while (c\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;c\u0026lt;=\u0026#39;7\u0026#39;){ if (c\u0026gt;\u0026#39;9\u0026#39;||c\u0026lt;\u0026#39;0\u0026#39;){ printf(\u0026#34;Error at Line %d: Invalid characters \\\u0026#39;%s\\\u0026#39;\\n\u0026#34;, yylineno, yytext); return -1; } buf[0]=c; buf[1]=\u0026#39;\\0\u0026#39;; total = total*8+atoi(buf); c = yytext[pos++]; } if (c!=\u0026#39; \u0026#39;\u0026amp;\u0026amp;c!=\u0026#39;\\t\u0026#39;\u0026amp;\u0026amp;c!=\u0026#39;\\n\u0026#39;\u0026amp;\u0026amp;c!=\u0026#39;\\0\u0026#39;){ printf(\u0026#34;Error at Line %d: Invalid octalnumber \\\u0026#39;%s\\\u0026#39;\\n\u0026#34;, yylineno, yytext); return -1; } printf(\u0026#34;\u0026lt;INTNUM, %d\u0026gt;\\n\u0026#34;, total); return 1; } else { c = yytext[pos++]; int total = 0; while ((c\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;c\u0026lt;=\u0026#39;9\u0026#39;)||(c\u0026gt;=\u0026#39;a\u0026#39;\u0026amp;\u0026amp;c\u0026lt;=\u0026#39;f\u0026#39;)||(c\u0026gt;=\u0026#39;A\u0026#39;\u0026amp;\u0026amp;c\u0026lt;=\u0026#39;F\u0026#39;)){ if (c\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;c\u0026lt;=\u0026#39;9\u0026#39;){ total = total*16 + c-\u0026#39;0\u0026#39;; } if (c\u0026gt;=\u0026#39;a\u0026#39;\u0026amp;\u0026amp;c\u0026lt;=\u0026#39;f\u0026#39;){ total = total*16 + c-\u0026#39;a\u0026#39;+10; } if (c\u0026gt;=\u0026#39;A\u0026#39;\u0026amp;\u0026amp;c\u0026lt;=\u0026#39;F\u0026#39;){ total = total*16 + c-\u0026#39;A\u0026#39;+10; } c = yytext[pos++]; } if (c!=\u0026#39; \u0026#39;\u0026amp;\u0026amp;c!=\u0026#39;\\t\u0026#39;\u0026amp;\u0026amp;c!=\u0026#39;\\n\u0026#39;\u0026amp;\u0026amp;c!=\u0026#39;\\0\u0026#39;){ printf(\u0026#34;Error at Line %d: Invalid hex number \\\u0026#39;%s\\\u0026#39;\\n\u0026#34;, yylineno, yytext); return -1; } printf(\u0026#34;\u0026lt;INTNUM, %d\u0026gt;\\n\u0026#34;, total); } } {identifier} {return IDENTIFIER;} [0-9]+ {printf(\u0026#34;\u0026lt;INTNUM, %d\u0026gt;\\n\u0026#34;,atoi(yytext));} . { printf(\u0026#34;Error at Line %d: Invalid characters \\\u0026#39;%s\\\u0026#39;\\n\u0026#34;, yylineno, yytext); } %% int main(int argc, char** argv) { if (argc \u0026gt; 1) { yyin = fopen(argv[1], \u0026#34;r\u0026#34;); if (!yyin) { perror(\u0026#34;Error opening file\u0026#34;); return 1; } } else { printf(\u0026#34;Usage: %s \u0026lt;filename\u0026gt;\\n\u0026#34;, argv[0]); return 1; } while (yylex() != 0); fclose(yyin); // Remember to close the file when done return 0; } int yywrap() { return 1; } 总结 本文实现了一个简单的SysY词法分析器，并且将在下一篇文章中利用Bison+FLex结合此词法分析器进行语法分析器的制作。\n","date":"2023-12-05T18:50:26+08:00","image":"https://cdn.hluvmiku.tech/image/202312051936450.png","permalink":"https://hluvmiku.tech/blog/build-sysy-lex-analyzer-with-flex/","title":"Build SysY Lex Analyzer With FLex"},{"content":" Tip\n本文提供了torch报错Trying to backward through the graph a second time (or directly access saved tensors after they have already been freed的深入排查解决方案\nNote\n排查方法摘要：\n确认是否在一个iter中多次反向传播 确认是否在多个iters之间没调用optimizer.zero_grad() 可视化并确认是否及时detach()了模型参数 前言 实操pytorch也有几年了，虽然都是兴趣使然的小打小闹，但是各种问题或多或少都碰到过。\n一般来说，绝大多数torch的报错都可以Google到，或者在StackOverflow中找到相关解决方案。\n再不济，也可以去GitHub里相关issue中找到解决方案。\n当然，作为最终武器，我们还有ChatGPT，在现在8k上下文的情况下，基本上可以解决大部分问题。\n但是很不幸，我遇到的是这个错误：\n1 RuntimeError: Trying to backward through the graph a second time (or directly access saved tensors after they have already been freed). Saved intermediate values of the graph are freed when you call .backward() or autograd.grad(). Specify retain_graph=True if you need to backward through the graph a second time or if you need to access saved tensors after calling backward. 我一共遇到了3次这个问题，我之所以说很不幸，是因为它debug起来极其困难，有的时候还会沦落到不得不可视化计算图的地步。 甚至问GPT，它都只会给我笼统地说检查我是不是backwards了多次什么的，毫无参考性。\n这个错误的意思是说在反向传播过程中，计算图在完成反向传播前就被释放了，导致无法再次反向传播。\n一般来说，我们在训练GAN时比较容易遇到，因为可能会有量要被要被反向传播训练G和D两个网络。这种情况下，就老老实实使用retain_graph=True就好了。\n其他情况请按照下文排查。\n常规检查 废话不多说，再深入研究代码前，先确定是不是由以下错误导致的：\n在一个iter中多次反向传播，即类似： 1 2 3 loss.backwards() # do something loss.backwards() 在多个iters之间没调用optimizer.zero_grad()，即类似： 1 2 3 4 for i in range(100): # do something loss.backwards() optimizer.step() 以上这两种情况请自行排查解决。\n继续深入 Note\n先说结论：某些该detach().clone()的地方没有detach().clone()。\n如果不知道是哪里需要detach().clone()，可以看我下方的实践。\n我没犯常规检查中的两个错误，但还是出现了这种问题🤔。\n迫不得已，我继续深入研究。\n我很快定位到问题出现在这一段代码：\n1 2 3 4 5 6 7 @property def get_xyz_purturbed(self): unc = sample_from_grid(self.grid, self._xyz.to(self._xyz.device).view(-1,3), self.lb, self.ub) noise = torch.normal(0, unc) # pdb.set_trace() noise = noise.to(self._xyz.device) return self._xyz + noise.reshape(*self._xyz.shape[:-1],1) 但是我不知道具体问题出在哪。\n被折磨了好久😩，迫不得已我装了个torchviz，用它的make_dot可视化了一下计算图。\n1 2 dot = make_dot(loss) dot.save(f\u0026#39;loss.txt\u0026#39;) *不要在意我画的圈，这是我之前和学长讨论的时候留下来的\n（在线可视化工具地址）\n其中，蓝色的方框是requires_grad=True的模型参数，橙色的方框是requires_grad=False的。灰色很显然是backwards的节点。\n因为之前我测试过，能确定问题出在左边部分的计算图，我很快注意到了这里： 可以看到，在这里出现了两个requires_grad=True的模型参数，这就是问题所在了。\n以下是我对这个问题的理解，可能有错误，欢迎指正。\n我认为出现这个问题是因为，一般来说，模型的计算图是类似于树一样的结构（不是很准确，因为非叶子结点之间互相可以连接），根节点是loss，叶子结点是模型参数，而像这样的畸形结构导致torch无法在正确的时机释放计算图，从而导致了这个错误。\n于是我优化了一下代码，将self._xyz（计算图中最顶上那个蓝色方块）detach并复制：\n1 2 3 4 5 6 7 @property def get_xyz_purturbed(self): unc = sample_from_grid(self.grid, self._xyz.cpu().detach().clone().to(self._xyz.device).view(-1,3), self.lb, self.ub) noise = torch.normal(0, unc) # pdb.set_trace() noise = noise.to(self._xyz.device) return self._xyz + noise.reshape(*self._xyz.shape[:-1],1) 这样就解决了问题。\n可以看看我修改后的计算图： 十分的干净利索。\n总结 多次反向传播是torch中较为棘手的问题，需要对torch的反向传播有一定的理解，并且要能完全明确自己的模型是如何backwards的。通常我们可以通过可视化计算图的方式来快速排查。\n","date":"2023-10-25T15:36:23+08:00","image":"https://cdn.hluvmiku.tech/image/202310251611268.png","permalink":"https://hluvmiku.tech/blog/solve-multi-times-backwards-in-pytorch/","title":"Solve Multi Times Backwards In pytorch"},{"content":" 1.1 如果在命令行下执行 gcc -DNEG -E sample.c -o sample.i 生成的 sample.i 与之前的有何区别? -D定义了NEG变量，因此在预处理时，M将被替换为-4，而不加-DNEG，M将赋值为4。 1.2 请对比 sample-32.s 和 sample.s ，找出它们的区别，并上网检索给出产生这些区别的原因。如: pushq 和 pushl pushl与pushq的区别在于操作的位数不同，具体来说pushl压入一个双字的长度即32位，而pushq压入一个四字的长度即64位。在32位系统中，ebp为32位，而在64位系统中，rbp为64位。 补充:\npushb：压入一个 byte（8 位） pushw：压入一个 word（16 位） pushl：压入一个 long（32 位） pushq：压入一个 quadword（64 位） rsp 和 esp 他们都是栈顶指针 esp为32位栈顶指针 rsp为64位栈顶指针 1.3 你可以用 clang 替换 gcc ，重复上面的各步，比较使用 clang 和 gcc 分别输出的结果有何异同。【本题可选】 GCC的输出如下：\n点击查看GCC生成的sample.s 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 .file\t\u0026#34;sample.c\u0026#34; .text .globl\tmain .type\tmain, @function main: .LFB0: .cfi_startproc pushq\t%rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq\t%rsp, %rbp .cfi_def_cfa_register 6 movl\t$4, -4(%rbp) cmpl\t$0, -4(%rbp) je\t.L2 addl\t$4, -4(%rbp) jmp\t.L3 .L2: sall\t$2, -4(%rbp) .L3: movl\t$0, %eax popq\t%rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size\tmain, .-main .ident\t\u0026#34;GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0\u0026#34; .section\t.note.GNU-stack,\u0026#34;\u0026#34;,@progbits clang的输出如下：\n点击查看clang生成的sample-clang.s 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 .text .file\t\u0026#34;sample.c\u0026#34; .globl\tmain # -- Begin function main .p2align\t4, 0x90 .type\tmain,@function main: # @main .cfi_startproc # %bb.0: pushq\t%rbp .cfi_def_cfa_offset 16 .cfi_offset %rbp, -16 movq\t%rsp, %rbp .cfi_def_cfa_register %rbp movl\t$0, -4(%rbp) movl\t$4, -8(%rbp) cmpl\t$0, -8(%rbp) je\t.LBB0_2 # %bb.1: movl\t-8(%rbp), %eax addl\t$4, %eax movl\t%eax, -8(%rbp) jmp\t.LBB0_3 .LBB0_2: movl\t-8(%rbp), %eax shll\t$2, %eax movl\t%eax, -8(%rbp) .LBB0_3: xorl\t%eax, %eax popq\t%rbp retq .Lfunc_end0: .size\tmain, .Lfunc_end0-main .cfi_endproc # -- End function .ident\t\u0026#34;clang version 6.0.0-1ubuntu2 (tags/RELEASE_600/final)\u0026#34; .section\t\u0026#34;.note.GNU-stack\u0026#34;,\u0026#34;\u0026#34;,@progbits ","date":"2023-10-24T14:56:42+08:00","image":"https://cdn.hluvmiku.tech/image/202310241500383.png","permalink":"https://hluvmiku.tech/blog/princlples-of-compiler-experiment2/","title":"Princlples of Compiler Experiment2"},{"content":" Tip\n本文汇总了我的所有编译原理实验报告，仅供参考。\n如有疑问或实验报告有误，可以留言，我会及时修改。\n实验命名以学习通的PDF为准。\n一些建议 建议在Ubuntu环境进行实验，否则会和实验文档有出入。 实验2 实验指南下载地址 实验报告链接 修改时间：2023/10/24 实验3 实验代码链接 修改时间：2023/12/5 ","date":"2023-10-24T14:48:51+08:00","image":"https://cdn.hluvmiku.tech/image/202310241501131.png","permalink":"https://hluvmiku.tech/blog/princlples-of-compiler-experiments/","title":"Princlples of Compiler Experiments"},{"content":" 文章的部分内容被密码保护，提示 “我的名字全拼小写”：\n--- DON'T MODIFY THIS LINE --- To Bigin With: 先讲讲实验室吧。\n折腾了一个暑假LERF和Segment Anything，但是在磨洋工。\n这周认真干了一两天就有突破了。（写文章的时候正在训练实验，显存不太够，故下图没有显示SAM的结果。） 但是还是太慢了，所谓“3个月技术迭代一轮”不假，在我还在慢慢磨LERF和Segment Anything时，Meta推出了LISA，而3D Gaussian Splatting，也悄无声息的成为了被认为是NeRF领域下一个热潮的新方向。 我之所以推进缓慢，一方面是我对每个细节都一定刨根问底，当我像这周一样急于求成而忽略内在实现的时候，当然，我也能做得很快，但是我不想。\n还有一方面就是，我之前一直认为我要走考研的路，而实验室目前的项目，还是以兴趣为主。\n但是事情戏剧性的发生了变化。\nDown To The Rabbit Hole: 暑假时，丁老师（我的导师）在一天早上8点给我打了一个电话，问我对于直博杭电有什么想法。 Without hasitate, 我拒绝了❌。\n我认为直博杭电，或者，往小里说，保研杭电，对我来说太没挑战性也太局限了。我现在还是这么认为。\n直到我开始认真准备考研，我才意识到考研的投机、取巧、残酷。\n我开始考虑留学。 这也有一个很大的观念上的变化。\nThe Story Of A Friend: 这就要提到一个高考位次比我低5000名，也在一所双非大学的高中同学了。\n我选择了杭电，计算机专业评级A。而他选了他们大学的物理强基计划。 事实证明，他的选择是正确的。\n在我苦苦为了一点点学术资源而奋斗的时候，全校的资源在往我同学身上倾斜——因为他在强基计划。\n在我跟导师做实验的时候，他在跟着院士做项目——因为他在强基计划。\n当我想要努力考研的时候，他们全班都有保研资格——因为他们在强基计划。\n当我开始查看留学机会的时候，他院长为了他能去苏黎世理工留学而争取把他送到北大交换——因为他在强基计划。\n至此，我彻底确信了一句话：“选择大于努力。”\nBack To (No) Future: 回到我自己的情况，我现在的情况是，我在考虑留学，但是我的绩点一般、其它软实力虽然有但是不好体现。\n所以我不得不将重心放回实验室上。 这才有了我上周的囫囵吞枣的突破。\n但接下来怎么办呢？还有一年。\n努力写论文？考GRE考雅思？刷绩点？\n都需要。\n这也是没办法的办法。 不过好在对于3D Gaussian Splatting，我有一肚子的思路灵感，也算是去年一年的沉淀吧。\nIn All： 接下来我要不求甚解的速通论文了，学生会、游戏、比赛我都得放下了。\n前两学期考虑了太多组织与集体，现在是时候考虑自身了。\n故记录一下这个时间节点。\n下为一些暑假以来的有意义的事情和部分照片。\n服务外包国赛二等奖以及又一家Apple Store 略显糟糕的同学会以及又一家Apple Store 学生会物料、假耳机以及Apple TV+上一部好影片 碎碎念： 寝室卫生真的糟透了，很难想象高中住在全校最干净寝室的人怎么活下来的。\n最近开始健身环，身体最重要。\n考研还是留学，下周末前定好。\n图片来自unsplash\n","date":"2023-10-19T21:09:08+08:00","image":"https://cdn.hluvmiku.tech/image/202310192152932.png","permalink":"https://hluvmiku.tech/blog/stage-summary-2023/10/19/","title":"Stage Summary 2023/10/19"},{"content":" Tip\n通过本文，你将了解： - 如何通过iCloud购买自定义域名 - 如何使用iCloud+创建自定义邮箱域名\nNote\n你需要一个非国区的Apple ID并且开通iCloud+服务才能完成本文的实践。\n1. 通过Apple购买自定义域名 Tip\n如果你已经有了自己的域名，可以跳过本节。\n在此处选择进入自定电子邮件域（若为国区，则访问此处,并选择购买新域。 输入你想要的域名，如hluvmiku.info，点击查找选择你喜欢的域名并点击继续。 在CloudFlare完成购买。请使用Apple ID登陆或注册Cloudflare账号。购买完成后，点击返回。 等待片刻，你将看到你的域名已经在iCloud中完成验证。\n2. 或者，你可以使用已有的域名 Tip\n如果你在iCloud中按照上一节的步骤购买了域名，可以跳过本节。\n在此处选择进入自定电子邮件域（若为国区，则访问此处,并选择添加您拥有的域并输入你的域名。 在下图所示的位置选择无电子邮件地址，我们将在下一节中创建自定义邮箱。 点击第三步的视图，并根据它所提供的信息在你的域名服务商中添加TXT记录、MX记录与CNAME记录。 完成配置后，单击第四步的验证，等待片刻，你将看到你的域名已经在iCloud中完成验证。\n3. 创建自定义邮箱 按下图即可创建自定义邮件。 4. 总结 至此，你已经完成了自定义域名的购买与配置，你可以在iCloud中使用自定义域名的邮箱了。\n另外，若你是在iCloud中通过Cloudflare购买的域名，也可以用自己的ID登陆Cloudflare管理你的域名。\n","date":"2023-10-10T19:44:57+08:00","image":"https://cdn.hluvmiku.tech/image/202310102031515.png","permalink":"https://hluvmiku.tech/blog/create-your-custom-email-domain-with-icloud-plus/","title":"Create Your Custom Email Domain With ICloud Plus"},{"content":" Tip\n本文将介绍Open Interpreter - 一个可以在终端调用GPT-4或本地的Code-llama的python库。\nNote\n点击此处查看官方中文文档。 👇官方宣传视频👇 1. 为什么选择 Open Interpreter？ 前段时间，OpenAI 发布了Code Interpreter，旨在给GPT提供一个有生命周期的notebook与一定的储存、运算资源与一个和用户传输文件的方式。它的问世在极大程度上便利了我的日常代码生活。我曾让它在不知道.pt模型结构的情况下，让它自行搭建模型以读取预训练好的checkpoint，也让他帮我统计过excel报表。可以说它是一个非常强大的工具。\n但，随着使用的深入，问题也逐渐暴露。\n先是我的excel中有部分敏感信息，这使我不得不在本地先进行脱敏处理，再上传给GPT统计报表，极大的影响了效率。\n再是，传输大文件极其依赖网络环境，如果我有一个2.5GB的文件要给Code Interpreter分析，我不得不等待很久。\n此外，OpenAI对其运行时长、内存、存储等资源都有一定的限制，这使得我无法在Code Interpreter上进行一些复杂的操作。\n最后，Code Interpreter依赖于预装好的一系列python库，并且不能联网，这极大的限制了它的使用场景。\n因此我选择了Open Interpreter，它可以在本地运行，可以联网，可以使用本地的所有python库，可以使用本地的所有资源，可以使用本地的所有文件，可以使用本地的所有命令行工具。\n一言以蔽之，你能在终端执行什么操作，Open Interpreter就能在终端执行什么操作，GPT能完成什么操作，它也能一样完成。并且，它可以调用本地或者Azure上的LLM模型以保证隐私。 2. 安装与运行 Tip\n推荐将其装在虚拟环境中，如果你打算长期使用，可以将此虚拟环境作为默认环境。\n我在一个常用的conda虚拟环境中进行安装，这个环境是我最常使用的环境。\n1 2 conda activate your_env pip install interpreter 安装完成后，你可以在终端中通过interpreter命令方便的调用它。 Tip\n第一次运行可能需要使用interpreter -y以提供权限。\n3. Open Interpreter可以做什么？ 正如它所说，它能进行文件管理、数据处理、网页抓取、系统操作、编码、自动化等等。\n点击查看原文 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026gt; what can you do? As an Open Interpreter, I can execute a wide range of tasks by running code on your machine. Here are some examples of what I can do: 1 File Management: I can create, read, update, and delete files on your system. I can also move files around and organize them into directories. 2 Data Processing: I can read and process data from various sources such as databases, APIs, and files. I can perform operations like filtering, sorting, aggregating, and transforming this data. 3 Web Scraping: I can fetch data from websites by parsing HTML and extracting the information you need. 4 System Operations: I can execute system commands, install software, and manage system processes. 5 Coding: I can write and execute code in various languages like Python, JavaScript, Shell, AppleScript, and HTML. 6 Automation: I can automate repetitive tasks on your computer. Please note that any code I run is executed on your machine with your full and complete permission. I\u0026#39;m here to help, so let me know what you need! 下面我将放一个我亲身经历的几个例子：\n将一个目录下所有.mobi文件转化为pdf 我举一个简单的例子：我想将一个目录下所有.mobi文件转化为pdf。\n让我们看看Open Interpreter的表现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026gt; 将/Users/haleyc/Downloads/FIRE\\ PUNCH\\ 炎拳 中的mobi转化为pdf Sure, I can help with that. We will use a tool called Calibre, which is a powerful and easy to use e-book manager. It can convert from a huge number of formats to a huge number of formats, including from MOBI to PDF. Here is the plan: 1 Check if Calibre is installed on your system. 2 If not, install Calibre. 3 Use Calibre\u0026#39;s command-line tools to convert the MOBI file to PDF. Let\u0026#39;s start with the first step, checking if Calibre is installed. calibre --version Would you like to run this code? (y/n) 首先，它会告诉你它的解决方案，然后询问你是否同意。\n它计划先确定是系统否安装了Calibre，如果没有，通过homebrew安装，这之后再进行转码。\n在实际执行过程中，由于网络中断，我只能通过输入继续按照最初计划让它继续执行。\n由于Calibre需要手动配置，我不得不手动配置完毕后再次执行。在配置完后，一切就变得十分顺利。\n点击查看效果图 4. 进阶用法 使用Azure：interpreter --use-azure 使用本地LLM：interpreter --local 使用GPT-3.5-turbo：interpreter --fast 此外，你也可以在python中以库的形式调用它。在此我不做介绍。\n","date":"2023-09-13T15:49:15+08:00","image":"https://cdn.hluvmiku.tech/image/202309131725183.png","permalink":"https://hluvmiku.tech/blog/use-llm-in-your-console/","title":"Use LLM in Your Console"},{"content":"杂谈就在这里了。\n我会在这里分享一些我想分享的东西。而不是技术分享。\n最近感觉脑子快被AI代替了，我还是希望能更多的自己思考一些事情，因此我打算在这里多些自己的思考。\n昨天老师问了一个很有趣的问题：“大专生和大学生有什么区别？”\n全班都笑了，我也笑了。\n看看，这是Copilot给我的回答，和老师讲的一模一样。\n但是兀的一阵冷汗，回顾我这几学期，我真的和大专生有区别吗？\n这几学期以来，我有多少时间是在学技术，又有多少时间是真正用我学的知识而不是技术运用到现实中、代码中、项目中来？\n其余时间我都在用学习各种技术，一遍遍造世界上无数人造过的轮子。\n为什么我会堕落至此？ 我不禁发问，为什么我会堕落至此？\n是的，我还记得大一入校我兴奋的学习技术，以此实现各种创新的灵感。\n而现在呢？知识-靠GPT，技术-靠GPT，甚至写文章的灵感都靠GPT。\n或许我可以将一切归咎于劣币驱逐良币，或许我可以说我被生活、被别有居心刻意利用我的人所迫，或许我可以说我被急功近利的课程计划所迫，不得已至此。\n但我不希望这么推脱。 我想我应该是被自己的懒惰所迫，我想我应该是被自己的贪婪所迫，我想我应该是被自己的无知所迫。\n我曾多少次打算重新学一遍高数、线代、概率论，但是我都没有坚持下来。\n为什么？我心急，我希望今天学习，明天就能出结果。\n这不好 但是我又能怎么改呢？现在的课程就突出一个急功近利，现在的社会就凸显一个只看效果。\n我本不想这么责怪，但是当我凭借一个完全靠生搬硬套、完全没有自己创新的项目拿到了服务外包国二，差几名就能拿到国一的时候，我不得不这么说。\n他人的期待、自己的抱负、社会的压力，这些都让我不得不这么做。\n但我不能这么做。 这是我最近焦虑的根源，也是因此，我最近很累。\n我究竟该以怎样的姿态立足于校园，立足于社会，立足于未来？ ","date":"2023-09-12T15:56:22+08:00","image":"https://cdn.hluvmiku.tech/blog/202309121602704.png","permalink":"https://hluvmiku.tech/blog/hello-gossip/","title":"Hello Gossip"},{"content":" Tip\n通过本文，你将了解：\niOS快捷指令的基本使用 如何利用快捷指令中OCR和ChatGPT for iOS将截图文字转换为提醒事项 你将得到视频所示的解决方案：\n点击查看视频 Note\n注意，你必须要能正常访问ChatGPT for iOS，否则无法使用本文中的快捷指令。\n完整的快捷指令可以在文末获取。\n1 前言 本人是一个彻头彻底的懒人，所以我一直在寻找能够提高效率的方法。\n很多时候我会遇到一些突发的事情预约，通常是以通知或者聊天的形式发送给我的。\n自己手动将其输入到提醒事项中，不免显得麻烦，一般情况下我就懒得手动去添加。\n而通知形式又五花八门，也不适合写一个死的程序用一些固定的pattern去匹配。\n因此我自然而然的想到了OCR+GPT的方案。\n而快捷指令正好提供了一套完备的调用方案，于是一切都变得水到渠成了。\n快捷指令 快捷指令是在iOS 12中引入的，它可以让你在不编写代码的情况下，通过拖拽的方式来创建一个自动化的工作流。\n经过多年的发展，快捷指令已然成为 Apple 生态的一大「神器」，配合上第三方应用的支持，它可以替你省下很多不必要的时间，极大地提升工作效率。\n下图为一个简单的快捷指令工作流： 什么是快捷指令？ 快捷指令是一种允许用户在 iOS 设备上自动执行一系列任务的工具。它的目的是简化和自动化日常任务，从而提高效率。用户可以创建自己的快捷指令，也可以从快捷指令图书馆中选择预先创建的快捷指令。\n快捷指令可以做什么？ 日常任务自动化：例如，设置一个“上班模式”，当你到达办公室时，它可以自动打开你的工作应用、设置手机为静音并连接到办公室的 Wi-Fi。 与第三方应用集成：许多第三方应用都支持快捷指令，这意味着你可以创建自动化工作流程，涉及多个应用的操作。 语音控制：与 Siri 集成，允许用户通过语音命令执行快捷指令。 Web 任务自动化：例如，自动下载某个网站的所有图片或将网页内容保存到你的笔记应用中。 文本操作：自动格式化文本、翻译文本或提取文本中的特定信息。 健康和健身：例如，自动记录你的饮食、锻炼或睡眠数据。 家庭自动化：与 HomeKit 集成，允许用户自动控制家中的智能设备。 如何创建快捷指令？ 打开“快捷指令”应用。 点击“创建个人快捷指令”。 选择你想要的动作并将其拖放到工作流程中。 为你的快捷指令命名并保存。 为什么选择快捷指令？ 它集成在 iOS系统中，可以便捷的调用iOS提供的众多功能，也能被如Siri、快捷手势等触发。 低代码、编写方便。 多端同步，你可以在iPhone、iPad、Mac上同步你的快捷指令。 便于分享，你可以将你的快捷指令分享给其他人，也可以从其他人那里获取快捷指令。 ChatGPT for iOS 这是ChatGPT for iOS的App Store链接，你可以在这里下载它。\n它提供了一个快捷指令，你可以通过它免费调用GPT 3.5，因此你可以用它来实现一些有趣的功能。\n在本文中，我将使用它提供的快捷指令来分析OCR出来的文本，并将其转换为提醒事项。\n实现方案 具体流程已经显而易见了：手动截屏 -\u0026gt; OCR -\u0026gt; GPT -\u0026gt; 提醒事项。\n那我们该如何实现呢？快捷指令已经提供了全部的接口，我们只需要将它们串联起来即可。\n截屏+OCR 我们假设用户是在手动截屏以后立刻调用快捷指令的，因此我们需要在快捷指令中获取最近的一张截屏。 获取截屏的方式有很多种，这里我使用了最简单的方式：获取最近的照片。 获取完截屏以后，我们需要将其传递给OCR，这里我们使用了OCR快捷指令。 具体如下：\n点击查看解决方案 ![202309121529215](https://cdn.hluvmiku.tech/blog/202309121529215.png) GPT 对于GPT，我们需要准备一段固定的文本作为Prompt，并拼接上OCR的输出作为输入。此处我们可以采用快捷指令中的文本与合并文本实现。下面是我的实现方案：\n点击查看解决方案 提醒事项 最后，我们将其转换为提醒事项即可。\n点击查看解决方案 ![202309121540354](https://cdn.hluvmiku.tech/blog/202309121540354.png) 完整快捷指令流程和代码 Note\n注意，你必须要能正常访问ChatGPT，否则无法使用下方的快捷指令。\n点击这里获得完整的快捷指令。\n","date":"2023-09-12T14:51:52+08:00","image":"https://cdn.hluvmiku.tech/blog/202309121546372.png","permalink":"https://hluvmiku.tech/blog/screenshot-to-reminders/","title":"Screenshot to Reminders"},{"content":" Tip\n通过本文，你将了解：\n如何在Google Cloud Platform创建项目 如何验证域名所有权 如何启用Google Search API 1 前言 网络上很多有关教程都是转载来转载去，质量很差，我不想看。\n于是我便跟着Google提供的文档一步步操作，最终成功了。\n现在我将经验总结如下，希望能帮助到你。\n2 Google Search API 介绍 Info\n我该使用`Google Search Console API`还是`Google Indexing API`? Google Search Console API 和 Google Indexing API 都是关于Google Search Console的API，但是它们的功能不同。 如果你是想通过API获取网站访问信息等,那么你应该使用Google Search Console API。\n如果你是想通过API提交网站给Google Search Console，那么你应该使用Google Indexing API。\n但是本文讲解的:\n如何在Google Cloud Platform创建项目 如何验证域名所有权 这两部分，对于Google Search Console API和Google Indexing API都是通用的。因为这些API都需要在Google Cloud Platform中创建项目，并且验证域名所有权。 并且在文末我也会附上激活Google Indexing API的方法。\n请放心阅读。\nTip\nGoogle Search API 全称为 Google Search Console API ，是Google提供的一套API，可以通过API的方式获取Google Search Console的数据并进行部分操作。\n以下为Google Search API全部功能，整理自官方文档：\n2.1 Search Analytics 查询网站的流量数据。\n方法 HTTP 请求 说明 查询 POST /sites/siteUrl/searchAnalytics/query 使用您定义的过滤条件和参数查询搜索流量数据。该方法会返回您定义的行键（维度）分组的零行或多行。您必须定义一个或多个日期的日期范围。 JSON POST 示例:\n1 2 3 4 5 6 POST https://www.googleapis.com/webmasters/v3/sites/https%3A%2F%2Fwww.example.com%2F/searchAnalytics/query { \u0026#34;startDate\u0026#34;: \u0026#34;2015-04-01\u0026#34;, \u0026#34;endDate\u0026#34;: \u0026#34;2015-05-01\u0026#34;, \u0026#34;dimensions\u0026#34;: [\u0026#34;country\u0026#34;,\u0026#34;device\u0026#34;] } 2.2 站点地图 方法 HTTP 请求 说明 delete DELETE /sites/siteUrl/sitemaps/feedpath 从此网站中删除站点地图。 get GET /sites/siteUrl/sitemaps/feedpath 检索关于特定站点地图的信息。 list GET /sites/siteUrl/sitemaps 列出为此网站提交的站点地图条目，或包含在站点地图索引文件中（如果请求中指定 sitemapIndex）。 提交 PUT /sites/siteUrl/sitemaps/feedpath 为网站提交站点地图。 2.3 协作平台 方法 HTTP 请求 说明 添加 PUT /sites/siteUrl 将网站添加到 Search Console 中的用户网站集。 delete DELETE /sites/siteUrl 从用户的 Search Console 网站集中移除某个网站。 get GET /sites/siteUrl 检索关于特定网站的信息。 list GET /sites 列出用户的 Search Console 网站。 2.4 网址检查 方法 HTTP 请求 说明 index.inspect POST /urlInspection/index:inspect 与 Google 索引中提供的网址相关的信息。 JSON POST 示例:\n1 2 3 4 5 6 POST https://searchconsole.googleapis.com/v1/urlInspection/index:inspect { \u0026#34;inspectionUrl\u0026#34;: \u0026#34;https://www.example.com/mypage\u0026#34;, \u0026#34;siteUrl\u0026#34;: \u0026#34;https://www.example.com/\u0026#34;, \u0026#34;languageCode\u0026#34;: \u0026#34;en-US\u0026#34; } 3 创建项目、配置服务号与验证域名所有权 3.1为什么要创建项目？ 在Google Cloud Platform的逻辑中，你的一切操作都是在项目下进行的。\n你的域名、站点、乃至API等都属于用户的资源，这些资源会在项目中进行管理。\n简单来说，项目就是一个容器，Google在你发出请求后看容器里是否有请求的主体、请求方是否可以访问容器、请求方是否有权限对容器中的资源进行操作。满足上述条件后，Google才会对你的请求进行处理。\n因此，想要调用Google SearchAPI，你必须创建一个项目，并在验证域名所有权后，才能通过API在项目中对资源进行操作。\n3.2 创建项目 打开Google Cloud Platform，并登录你的Google账号。 点击右上角的 Select a project ，然后点击 New Project 。创建一个新的项目。 这样，你就创建了一个新的项目。\n3.3 配置服务号 打开服务账号页面。 点击 add 创建服务帐号，并输入服务帐号的名称和说明。您可以使用默认服务帐号 ID，也可以选择其他唯一的帐号 ID。完成后，点击创建。 后面的 服务帐号权限（可选） 部分无需设置。点击继续。 在 向用户授予访问此服务帐号的权限 屏幕上，向下滚动到创建密钥部分。点击 add 创建密钥。 在随即显示的侧面板中，选择密钥的格式。建议使用 JSON。 点击创建。你的新公钥/私钥对随后会生成并下载到您的计算机。 这样，你就创建了一个新的服务号，并下载了私钥。在完成本教程后，你可以用这个私钥访问你需要的API。 Warning\n请妥善保管你的私钥，你的私钥只能在创建时下载一次，如果丢失，你将无法再次下载。\n3.4 验证域名所有权 你可以在这里验证域名所有权。\n3.5 将服务账号添加为网站所有者 在这里将服务账号添加为网站所有者。\n选择添加用户。 在添加新用户对话框中，输入服务帐号的电子邮件地址。（在 3.3 步骤2中创建的服务帐号邮箱，形如my-service-account@project-name.google.com.iam.gserviceaccount.com） 将权限设置为“所有者”。 点击添加。 这样，你就将服务账号添加为网站所有者了。\n4 启用Google Search Console API 点击这里即可启用Google Search Console API.\n此外，点击这里即可启用Google Indexing API.\n这样，你就可以通过你的私钥调用Google Search Console API了。\n5 结语 通过本文，你应该已经了解了如何启用Google Search Console API，以及如何调用Google Search Console API。\n在一开始写这篇文章的时候，我混淆了Google Search Console API和Google Indexing API的逻辑，写到一半才意识到网站资源、token、域名所有权验证之间的逻辑关系，于是我把整篇文章重写了一遍。\n可谓教学相长了。\n","date":"2023-08-29T16:24:49+08:00","image":"https://cdn.hluvmiku.tech/blog/202308301902385.png","permalink":"https://hluvmiku.tech/blog/how-to-enable-google-search-console-api/","title":"How to Enable Google Search Console API"},{"content":" Tip\n通过本文，你将了解：\nGitHub Actions的基本使用 如何使用GitHub Actions自动推送URL至Google Search Console 如何使用GitHub Actions自动推送URL至百度站长平台 你将得到以下方案：\n使用GitHub Actions每天定时自动推送URL至Google Search Console与百度站长平台 Note\n本方案基于使用GitHub Actions自动部署你的博客中将站点部署到GitHub Pages的方案，并在它的基础上配置GitHub Actions实现自动推送。\n如果你没有使用过上述方案，也可以参考本文，只需自行获得站点的sitemap.xml即可。\n1 前言 新的博客总是会遇到一个问题：如何让搜索引擎知道我的博客的存在？\n这就需要我们将站点的sitemap.xml提交给搜索引擎。\n但是有的时候，仅仅提交sitemap.xml是不够的。\n最有效的方式是将你的站点所有希望被索引的URL推送给搜索引擎。\n不过，这个过程是比较繁琐的。\n本着“懒人”的原则，我研究了一套使用GitHub Actions来实现自动推送URL到Google和百度的方案。\n2 GitHub Actions 基本使用 点击查看GitHub Action介绍，熟悉的人可以跳过 2.1 GitHub Actions 简介 GitHub Actions是GitHub提供的一项功能，它可以让你在GitHub上自动化地完成一些操作。\n它的配置文件是.yml文件，放在.github/workflows目录下。\n它的结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 name: \u0026lt;workflow-name\u0026gt; # workflow的名称 on: \u0026lt;workflow-trigger\u0026gt; # workflow的触发条件 permissions: # workflow的权限 contents: read issues: write env: # workflow的环境变量 ENV: production jobs: # workflow的工作 build: runs-on: ubuntu-latest # 运行环境 steps: # workflow的步骤 - name: Checkout # 步骤名称 uses: actions/checkout@v2 # 步骤使用的action with: # 步骤的参数 ref: master fetch-depth: 0 ### 或者 ### - name: Checkout # 步骤名称 run: echo \u0026#34;Hello World\u0026#34; # 步骤的命令 具体来说：\nname: 定义工作流的名称。 on: 定义触发工作流的条件，例如 push、pull request 或定时任务。 permissions: 定义工作流的权限，例如读取内容或写入问题。 env: 定义工作流的环境变量。 jobs: 定义工作流中的任务。 runs-on: 定义任务运行的环境。 steps: 定义任务的步骤。 name: 定义步骤的名称。 uses: 定义步骤使用的 action。 with: 定义步骤的参数。 run: 定义步骤的命令。 当你的仓库中有.yml文件时，GitHub会自动检测并根据触发条件执行它。\n2.2 GitHub Actions 示例 点击查看示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 # Sample workflow for building and deploying a Hugo site to GitHub Pages name: Deploy Hugo site to Pages on: # Runs on pushes targeting the default branch push: branches: [\u0026#34;main\u0026#34;] # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages permissions: contents: read pages: write id-token: write # Environment variables available to all jobs and steps in this workflow env: HUGO_ENV: production HUGO_VERSION: \u0026#34;0.115.4\u0026#34; GO_VERSION: \u0026#34;1.20.5\u0026#34; NODE_VERSION: \u0026#34;18.15.0\u0026#34; TINA_CLIENT_ID: ${{ vars.TINA_CLIENT_ID }} TINA_TOKEN: ${{ vars.TINA_TOKEN }} jobs: # Build job build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Set up Node.js uses: actions/setup-node@v3 with: node-version: ${{ env.NODE_VERSION }} - name: Install Hugo run: | curl -LO \u0026#34;https://github.com/gohugoio/hugo/releases/download/v${{ env.HUGO_VERSION }}/hugo_extended_${{ env.HUGO_VERSION }}_Linux-64bit.tar.gz\u0026#34; tar -xvf hugo_extended_${{ env.HUGO_VERSION }}_Linux-64bit.tar.gz sudo mv hugo /usr/local/bin/ rm hugo_extended_${{ env.HUGO_VERSION }}_Linux-64bit.tar.gz hugo version - name: Install Go run: | curl -LO \u0026#34;https://dl.google.com/go/go${{ env.GO_VERSION }}.linux-amd64.tar.gz\u0026#34; sudo tar -C /usr/local -xzf go${{ env.GO_VERSION }}.linux-amd64.tar.gz echo \u0026#34;export PATH=$PATH:/usr/local/go/bin\u0026#34; \u0026gt;\u0026gt; $GITHUB_ENV rm go${{ env.GO_VERSION }}.linux-amd64.tar.gz go version - name: Setup Project run: npm run project-setup - name: Install npm dependencies run: npm install - name: Build Website run: npm run build - name: Upload artifact uses: actions/upload-pages-artifact@v1 with: path: ./public - name: Echo CNAME run: echo ${{ secrets.CNAME }} \u0026gt; ./public/CNAME - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} EXTERNAL_REPOSITORY: HaleyCH/HaleyCH.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} 这个例子是我在使用GitHub Actions自动部署你的博客中使用的配置文件。它依次实现了：\n安装 Node.js 安装 Hugo 安装 Go 安装 npm 依赖 构建站点 上传构建好的站点到 GitHub Pages 仓库 部署 GitHub Pages 仓库 将 CNAME 文件写入 public 目录 推送 GitHub Pages 仓库 并且，每当这个仓库的代码被改变时，它都会自动执行。\n可以看到GitHub Action是一个非常强大的工具，它可以帮助我们自动化地完成一些操作。\n通过它，我们可以实现自动推送URL到Google和百度的功能。 Note\nGitHub Actions有每月配额的限制，如果你的仓库中有多个workflow，那么你可能会遇到配额不足的情况。\n不过对于个人博客来说，这个配额是足够的。\nTip\n开通GitHub Pro或者通过GitHub Education认证可以获得更多的配额。\n3 自动推送URL至Google Search Console Info\n本节的内容需要你已经拥有一个Google Search Console账号，并且已经验证了你的域名所有权。\n具体流程可以参考如何启用Google Search Console API。\n本节假设你已经拥有了json格式的网站访问令牌。\n通过使用python的oauth2client库，我们可以实现自动推送URL至Google Search Console的功能。\n请遵循以下步骤：\n在你的仓库中，创建一个名为push_urls_to_google.py的文件，内容如下： 点击查看代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 from oauth2client.service_account import ServiceAccountCredentials import httplib2 import json import sys # https://developers.google.com/search/apis/indexing-api/v3/prereqs#header_2 JSON_KEY_FILE = \u0026#34;api-key.json\u0026#34; SCOPES = [\u0026#34;https://www.googleapis.com/auth/indexing\u0026#34;] def main(urls_file): credentials = ServiceAccountCredentials.from_json_keyfile_name(JSON_KEY_FILE, scopes=SCOPES) http = credentials.authorize(httplib2.Http()) ENDPOINT = \u0026#34;https://indexing.googleapis.com/v3/urlNotifications:publish\u0026#34; with open(urls_file, \u0026#34;r\u0026#34;) as f: urls = f.readlines() for u in urls: content = {} content[\u0026#39;url\u0026#39;] = u.strip() content[\u0026#39;type\u0026#39;] = \u0026#34;URL_UPDATED\u0026#34; json_ctn = json.dumps(content) response, content = http.request(ENDPOINT, method=\u0026#34;POST\u0026#34;, body=json_ctn) result = json.loads(content.decode()) if \u0026#34;error\u0026#34; in result: print(\u0026#34;Error({} - {}): {}\u0026#34;.format(result[\u0026#34;error\u0026#34;][\u0026#34;code\u0026#34;], result[\u0026#34;error\u0026#34;][\u0026#34;status\u0026#34;], result[\u0026#34;error\u0026#34;][\u0026#34;message\u0026#34;])) else: print(\u0026#34;urlNotificationMetadata.url: {}\u0026#34;.format(result[\u0026#34;urlNotificationMetadata\u0026#34;][\u0026#34;url\u0026#34;])) print(\u0026#34;urlNotificationMetadata.latestUpdate.url: {}\u0026#34;.format(result[\u0026#34;urlNotificationMetadata\u0026#34;][\u0026#34;latestUpdate\u0026#34;][\u0026#34;url\u0026#34;])) print(\u0026#34;urlNotificationMetadata.latestUpdate.type: {}\u0026#34;.format(result[\u0026#34;urlNotificationMetadata\u0026#34;][\u0026#34;latestUpdate\u0026#34;][\u0026#34;type\u0026#34;])) print(\u0026#34;urlNotificationMetadata.latestUpdate.notifyTime: {}\u0026#34;.format(result[\u0026#34;urlNotificationMetadata\u0026#34;][\u0026#34;latestUpdate\u0026#34;][\u0026#34;notifyTime\u0026#34;])) if __name__ == \u0026#34;__main__\u0026#34;: if len(sys.argv) \u0026lt; 2: print(\u0026#34;Usage: python push_urls_to_google.py \u0026lt;urls_file\u0026gt;\u0026#34;) else: urls_file = sys.argv[1] main(urls_file) 并将`json`格式的`Google SearchAPI`凭据命名为`api-key.json`，放在仓库的根目录下。 当然，安全起见，你也可以将它放在`GitHub Secrets`中，然后在`push_urls_to_google.py`中读取它。但是我的workflow并没有实现这个功能，读者可以自行实现。 这段代码将读取同目录下`api-key.json`并从输入中读取待推送的URL列表，并将它们推送至Google Search Console。 Warning\n请务必将仓库设为private，否则你的Google SearchAPI凭据将会被公开。\n在你的仓库.github/workflows目录下，创建一个名为push_urls_to_google.yml的文件，设定如下所示的触发条件: 1 2 3 4 5 6 7 8 9 10 11 name: Push Latest URLs Once a Day on: schedule: - cron: \u0026#34;0 0 * * *\u0026#34; workflow_dispatch: # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages permissions: contents: read pages: write id-token: write 这表示这个Action将在UTC时间的每天0点自动执行。\n获得sitemap.xml的URL。 如果你是根据使用GitHub Actions自动部署你的博客中的方案部署的博客，那么你可以在push_urls_to_google.yml中添加以下代码： 点击查看代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 jobs: # Build job build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Set up Node.js uses: actions/setup-node@v3 with: node-version: ${{ env.NODE_VERSION }} - name: Install Hugo run: | curl -LO \u0026#34;https://github.com/gohugoio/hugo/releases/download/v${{ env.HUGO_VERSION }}/hugo_extended_${{ env.HUGO_VERSION }}_Linux-64bit.tar.gz\u0026#34; tar -xvf hugo_extended_${{ env.HUGO_VERSION }}_Linux-64bit.tar.gz sudo mv hugo /usr/local/bin/ rm hugo_extended_${{ env.HUGO_VERSION }}_Linux-64bit.tar.gz hugo version - name: Install Go run: | curl -LO \u0026#34;https://dl.google.com/go/go${{ env.GO_VERSION }}.linux-amd64.tar.gz\u0026#34; sudo tar -C /usr/local -xzf go${{ env.GO_VERSION }}.linux-amd64.tar.gz echo \u0026#34;export PATH=$PATH:/usr/local/go/bin\u0026#34; \u0026gt;\u0026gt; $GITHUB_ENV rm go${{ env.GO_VERSION }}.linux-amd64.tar.gz go version - name: Setup Project run: npm run project-setup - name: Install npm dependencies run: npm install - name: Build Website run: npm run build - name: Upload artifact uses: actions/upload-pages-artifact@v1 with: path: ./public - name: Echo CNAME run: echo ${{ secrets.CNAME }} \u0026gt; ./public/CNAME - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} EXTERNAL_REPOSITORY: HaleyCH/HaleyCH.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} 它将自动部署你的网页，这样你就可以获得`sitemap.xml`了。 对于其他方案，你需要自行获得sitemap.xml并将其读入workflow中。\n在push_urls_to_google.yml中添加以下代码： 1 2 3 4 - name: Extract Latest URLs run: | latest_urls=$(grep -o \u0026#39;\u0026lt;loc\u0026gt;[^\u0026lt;]*\u0026lt;/loc\u0026gt;\u0026#39; ./public/sitemap.xml | sed \u0026#39;s/\u0026lt;loc\u0026gt;\\(.*\\)\u0026lt;\\/loc\u0026gt;/\\1/\u0026#39; | head -n 100) echo \u0026#34;$latest_urls\u0026#34; \u0026gt; latest_urls.txt 他将读取./public/sitemap.xml中的前100条URL，并将它们写入latest_urls.txt中。\n配置环境并运行脚本： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 - name: install python uses: actions/setup-python@v2 with: python-version: \u0026#39;3.x\u0026#39; - name: Install dependencies run: | python -m pip install --upgrade pip pip install oauth2client pip install httplib2 - name: Push Latest URLs to Google run: | pwd ls -l python ./push_urls_to_google.py latest_urls.txt 这段代码会自动配置python环境与依赖项，并且运行push_urls_to_google.py脚本。\n4 自动推送URL至百度站长平台 Info\n本节的内容需要你已经拥有一个百度站长平台账号，并且已经验证了你的域名所有权。\n由于这一步较为简单，我不会详细讲解。\n在workflow中添加以下代码即可:\n1 2 3 4 5 - name: Push Latest URLs to Baidu run: | while IFS= read -r url; do curl -H \u0026#34;Content-Type:text/plain\u0026#34; --data-binary \u0026#34;$url\u0026#34; \u0026#34;http://data.zz.baidu.com/urls?site=\u0026lt;yourDomain\u0026gt;\u0026amp;token=\u0026lt;yourToken\u0026gt;\u0026#34; done \u0026lt; latest_urls.txt 它会自动读取latest_urls.txt中的URL，并将它们推送至百度站长平台。\n5 完整的workflow 点击查看完整的workflow 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 name: Push Latest URLs Once a Day on: schedule: - cron: \u0026#34;0 0 * * *\u0026#34; workflow_dispatch: # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages permissions: contents: read pages: write id-token: write # Environment variables available to all jobs and steps in this workflow env: HUGO_ENV: production HUGO_VERSION: \u0026#34;0.115.4\u0026#34; GO_VERSION: \u0026#34;1.20.5\u0026#34; NODE_VERSION: \u0026#34;18.15.0\u0026#34; TINA_CLIENT_ID: ${{ vars.TINA_CLIENT_ID }} TINA_TOKEN: ${{ vars.TINA_TOKEN }} jobs: # Build job build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Set up Node.js uses: actions/setup-node@v3 with: node-version: ${{ env.NODE_VERSION }} - name: Install Hugo run: | curl -LO \u0026#34;https://github.com/gohugoio/hugo/releases/download/v${{ env.HUGO_VERSION }}/hugo_extended_${{ env.HUGO_VERSION }}_Linux-64bit.tar.gz\u0026#34; tar -xvf hugo_extended_${{ env.HUGO_VERSION }}_Linux-64bit.tar.gz sudo mv hugo /usr/local/bin/ rm hugo_extended_${{ env.HUGO_VERSION }}_Linux-64bit.tar.gz hugo version - name: Install Go run: | curl -LO \u0026#34;https://dl.google.com/go/go${{ env.GO_VERSION }}.linux-amd64.tar.gz\u0026#34; sudo tar -C /usr/local -xzf go${{ env.GO_VERSION }}.linux-amd64.tar.gz echo \u0026#34;export PATH=$PATH:/usr/local/go/bin\u0026#34; \u0026gt;\u0026gt; $GITHUB_ENV rm go${{ env.GO_VERSION }}.linux-amd64.tar.gz go version - name: Setup Project run: npm run project-setup - name: Install npm dependencies run: npm install - name: Build Website run: npm run build - name: Upload artifact uses: actions/upload-pages-artifact@v1 with: path: ./public - name: Echo CNAME run: echo ${{ secrets.CNAME }} \u0026gt; ./public/CNAME - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} EXTERNAL_REPOSITORY: HaleyCH/HaleyCH.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} - name: Extract Latest URLs run: | latest_urls=$(grep -o \u0026#39;\u0026lt;loc\u0026gt;[^\u0026lt;]*\u0026lt;/loc\u0026gt;\u0026#39; ./public/sitemap.xml | sed \u0026#39;s/\u0026lt;loc\u0026gt;\\(.*\\)\u0026lt;\\/loc\u0026gt;/\\1/\u0026#39; | head -n 100) echo \u0026#34;$latest_urls\u0026#34; \u0026gt; latest_urls.txt - name: Push Latest URLs to Baidu run: | while IFS= read -r url; do curl -H \u0026#34;Content-Type:text/plain\u0026#34; --data-binary \u0026#34;$url\u0026#34; \u0026#34;http://data.zz.baidu.com/urls?site=hluvmiku.tech\u0026amp;token=x1rQVPzQUzr3sm35\u0026#34; done \u0026lt; latest_urls.txt - name: install python uses: actions/setup-python@v2 with: python-version: \u0026#39;3.x\u0026#39; - name: Install dependencies run: | python -m pip install --upgrade pip pip install oauth2client pip install httplib2 - name: Push Latest URLs to Google run: | pwd ls -l python ./push_urls_to_google.py latest_urls.txt 6 结语 使用GitHub Actions可以将许多琐碎的、重复的工作自动化，让我们可以专注于更有意义的事情。\n本文我提出了一套自动化推送方案，但是它仍然存在推送不够智能的问题。\n大家有兴趣可以自行研究。\n","date":"2023-08-29T16:16:49+08:00","image":"https://cdn.hluvmiku.tech/blog/202308291727641.png-small.webp","permalink":"https://hluvmiku.tech/blog/automatic-submit-your-page/","title":"Automatic Submit Your Page"},{"content":" Note\n本教程需要你拥有一张ESP-32、STM32或者CH32开发板。并且本文只基于ESP-32进行讲解。\n1 前言 本文只是一个粗浅的教程，详细可以加QQ群946057081讨论。\n在开始正文前，我想先列举一下我尝试过的方案。\nNXBT:这是目前最火的项目，但是它要求使用树莓派或者linux系统的PC。\n树莓派太贵，所以我没采用。\n之后我又折腾过 WSL、VMWare、VirtualBox，但是都没成功。\nVMWare是我最接近成功的一次，有兴趣各位可以试试。\n而且此项目年久失修，我估计switch到16.0固件以后就没法用了。 NintendoSwitchController: 纯日语项目，很不友好，需要Arduino Leonardo，贵。 EasyCon：本文主角。支持多种单片机，价格控制在50元人民币以内，可以自制脚本，接上采集卡还能使用图像识别（采集卡要另外买，差不多200来块），功能强大。 2 准备工作 2.1 下载整合包 首先，你需要下载整合包。\n这里我提供了交流群中2022年12月更新的文件：\nESP-32 STM32 CH32 点击下载ESP32整合包\n点击下载STM32整合包\n点击下载CH32整合包\n你可以根据自己的需求选择下载不同的文件。\n2.2 购买对应的开发板 建议根据下载的整合包里的PDF文件购买开发板。\n2.2.1 ESP-32 我使用的是ESP-32。\nNote\n请注意不要购买ESP32-Cx、 ESP32-Sx型号。\n并且最好购买带有`cp2102关键字的开发版。\n薄膜键盘可以不用买，但是数据线一定要买，是比较老的那种接口，具体可以问客服。\n针脚可以联系客服让厂商帮你焊好（不焊也可以用）。\n这里是我的购买截图 2.2.2 其他 请参考整合包中PDF文件进行购买。\n2.3 安装驱动 如果整合包中包含驱动，则安装驱动，\n若无，直接进行下一步。\n2.4 烧录固件 所有的整合包中都包含EasyCon固件以及烧录文件，你可以直接烧录。\n下面我将以ESP-32为例进行讲解。\n1、 启动烧录程序。点击烧录程序后，选择ESP32，然后点击OK。\n你应该会看到如图所示界面 2、 点击...，选择整合包中的固件，并选中。在后方的地址输入 0x0。并选择正确的串口。\n3、 点击start\n出现如图所示的界面代表烧录成功 3 使用EasyCon 3.1 下载EasyCon并使用 你可以在这里找到对应文件。\n下载并解压他们。\n打开后你会看到这样的界面。\n点击自动连接即可与开发版连接。\n3.2 EasyCon语法介绍 按键 语法：键位 [持续时间(ms)|DOWN|UP] 示例：A（按下A键50毫秒）、HOME 1000（按下Home键1秒）、LEFT DOWN（按住左十字键，需要手动用LEFT UP松开） 全部按键：A、B、X、Y、UP、DOWN、LEFT、RIGHT、MINUS、PLUS、L、R、ZL、ZR、HOME、CAPTURE。 摇杆 语法： LS|RS 方向|角度 [, 持续时间(ms)] LS|RS RESET LSS|RSS 方向 (1.45新增慢推语法，仅支持方向，不支持角度) 等待 语法：[WAIT] 等待时间(ms) 示例：WAIT 500、2000 注释 语法：# 注释内容 注意：多写注释是个好习惯，尤其是分享脚本给别人的时候。 输出 语法：PRINT 输出内容 注意：联机模式专用，在控制台显示文字。 消息推送 语法：ALERT 输出内容 注意：联机模式专用，发送推送消息，基于推送加服务。需要先关注\u0026lt;pushplus推送加\u0026gt;小程序生成token并在设置-\u0026gt;推送设置页面配置。 循环 语法： FOR [循环次数]\n\u0026hellip;\nNEXT 常量与变量 常量语法：常量名 = 值 变量基础语法：$索引 变量进阶语法：$变量名、$$变量名 赋值 语法：目标变量 = 值 或 目标变量 = 来源变量 含变量的基础语句 输出：PRINT 用\u0026amp;分隔的输出内容 按键：键位 变量名 摇杆：LS|RS 方向|角度 变量名 等待：WAIT 变量名 条件分支 语法： IF 条件\n\u0026hellip;\nELSE \u0026hellip; ENDIF 4 部分脚本 自动刷活动 Note\n需要不在同行第一只宝可梦放刷活动用宝可梦，并且该宝可梦第一个技能应该为需要使用的技能。\n使用时，需连接网络，并进入联机太晶对战界面再运行脚本。\n此外，还需要将捕捉用的精灵球选择为普通球（否则太浪费）并且买999个。\n1 2 3 4 5 6 FOR X 100 WAIT 100 A 100 WAIT 100 NEXT 自动取孵 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 #1.语速调到最快，关闭取名，关闭学技能，自动记录最好关闭 #2.将【园模镇：西】标记为目的地，并打开原地旋转模式 #3.同行携带要生蛋的两只宝可梦 #4.将盒子打开的界面调成将要放蛋的第一个空箱子 #5.放蛋的空箱子的前一个箱子第一列空出来，第二列只放火焰之躯宝可梦【孵蛋用】 #6.菜单界面光标默认调到野餐，脚本开始时人物退出盒子，退出菜单，并骑上神兽 #7.初始站位需站在园模镇橄榄球场远离可梦中心球筐左侧，面朝宝可梦中心，球筐在右侧 #8.默认20周期的，孵其他宝可梦，孵蛋时间需自行调节，料理位置按自己的配方调整 #9.部分延时为防止卡顿，加的时间有点长，可自行修改，如果野餐不成功，请重新开始即可 #10.by 倚夏\u0026amp;law 宝可梦取孵一体脚本2.86【圆模镇】(往复式孵蛋) #【※※※※运行前清修改数值※※※※】 #======初始数值调整【必看】====== _孵蛋箱数 = 1 #需自行计算箱数，一次料理54+颗蛋左右【一次料理，孵蛋两箱，约1.5小时】 _孵蛋周期 = 25 #直接填写孵蛋宝可梦的孵蛋周期，可看下方的周期表 _料理次数 = 4 #一次料理54颗蛋左右，根据料理次数换算成你要孵蛋的箱数 _料理位置 = 8 #就是17号配方【超级花生酱三文治】在第几行 _料理左右 = 0 #就是17号配方【超级花生酱三文治】在 0左 还是 1右 _跳过野餐 = 1 #1开启，不进行野餐直接孵蛋，初始站位不变，并将光标放到孵蛋的第一箱第一个蛋，同行只有一只孵蛋用宝可梦 _蛋蛋力LV3 = 1 #1开启，将制作蛋蛋力LV3，需要两个甜味料和一份生菜，一次料理85颗左右 _甜味料位置 = 5 #倒数第几行 #======进阶调整数值【可选】====== _孵蛋延时 = 60 #默认60，如果存在没孵出来的蛋，打开图鉴或者服装，自行加大，每加1延迟孵蛋时间2秒 _拿取延时 = 100 #默认100，改小增大吞键可能性 _按键延迟 = 500 #默认500，按键间隔的延迟 _复位功能 = 1 #1开启 0关闭 _复位周期 = 3 #几箱复位一次 _往对侧 = 3500 #往球场对侧方向行走时间 _往中心 = 1500 #往球场中心方向行走时间 _闪光识别 = 0 #1开启，需用采集卡，并自制标签，烧录需注释【@闪光】 _自动放生闪光识别 = 0 #1开启，需用采集卡，烧录需删除放生代码 #自行按照以下周期选择适合的（周期数据查询神奇百科） #网站：https://wiki.52poke.com/wiki/宝可梦列表（按孵化周期分类） #孵蛋时间有盈余的，会在第一个蛋的界面空转几圈 #5周期= 5 例如鲤鱼王 #10周期=10 例如一对鼠 #15周期=15 例如斗笠菇 #20周期=20 例如小火龙 #25周期=25 例如冰砌鹅 #30周期=30 例如沙河马 #35周期=35 例如伊布 #40周期=40 例如烈咬陆鲨 #函数-------------------------- FUNC POINT #朝向目的地 600 Y 200 2700 B 200 2000 L 100 400 ENDFUNC #函数-------------------------- # 准备阶段 FOR 5 RCLICK 200 NEXT #开始运行 $5 = _跳过野餐 IF $5 = 0 #自动野餐---------------------------------------------------- PRINT 自动野餐开始 CALL POINT LS 270,500 500 LS 270 B 200 WAIT 1500 LS RESET 300 LS 90,2000 200 PLUS 200 300 LS 270,700 CALL POINT PRINT 走到野餐位置，开始野餐 FOR 3 X 50 50 NEXT FOR 5 50 A 100 50 NEXT WAIT 7000 #等待野餐时间 L 500 WAIT 1000 #走到篮子位置 LS UP,200 WAIT _按键延迟 LS LEFT,320 WAIT _按键延迟 LS UP,500 WAIT _按键延迟 LS RIGHT,330 WAIT _按键延迟 LS DOWN,300 WAIT 500 #做料理 $1 = 1 FOR _料理次数 500 PRINT 开始做料理 LS DOWN,200 WAIT _按键延迟 FOR 10 50 A 100 50 NEXT WAIT 5000 #等待选配方界面 $5 = _蛋蛋力LV3 IF $5 = 0 #17号料理 根据料理位置设置次数 PRINT 制作17号料理 $4 = _料理位置 $4 -= 1 FOR $4 LS DOWN,100 100 NEXT $4 = _料理左右 #判定料理配方在左右 IF $4 = 0 #在左 WAIT 100 ELSE #在右 LS RIGHT,100 WAIT 200 ENDIF WAIT _按键延迟 FOR 5 50 A 100 50 NEXT WAIT 8000 #开始做三文治 FOR 3 LS 90,550 100 A DOWN 100 LS 270,525 A UP 100 NEXT #放面包和签子 WAIT 3000 LS UP,550 WAIT _按键延迟 FOR 120 #等三文治转圈画面 50 A 100 50 NEXT $5 = 7 #蛋蛋力LV2拿蛋7轮 $4 = 23 ELSE PRINT 制作蛋蛋力LV3料理 $4 = _甜味料位置 X 200 200 A 200 200 PLUS 200 200 FOR $4 100 UP 100 100 NEXT 200 FOR 2 100 A 100 100 NEXT 200 PLUS 200 200 A 200 WAIT 8000 #等待做料理 LS UP,550 FOR 130 #等三文治转圈画面 50 A 100 50 NEXT $5 = 10 #蛋蛋力LV3拿蛋10轮 $4 = 16 ENDIF 8000 #吃料理时间 A 200 2000 PRINT 吃料理时间 PRINT 吃了 \u0026amp; $1 \u0026amp; 次料理 $1 += 1 LS UP,45 WAIT _按键延迟 # 拿蛋阶段 PRINT 开始拿蛋 $3 = 1 FOR $5 #等待过程中每10秒吹一次口哨 FOR $4 R 200 WAIT 10000 NEXT #连A拿蛋 FOR 52 A 100 WAIT 300 NEXT #连B取消对话框 300 B 100 WAIT 300 B 100 WAIT 300 #循环一次时间5分 PRINT 拿蛋 \u0026amp; $3 \u0026amp; 轮 $3 += 1 NEXT # 返回循环做料理 NEXT PRINT 野餐拿蛋结束 # 结束野餐 2000 FOR 5 50 Y 100 50 NEXT FOR 13 150 A 200 150 NEXT 200 PRINT 开始返回球场 LS 270,200 500 PLUS 600 #返回球场 500 LS 90,1200 #走到栏杆边 200 LS 90 B 300 1000 LS RESET CALL POINT LS 270,1000 #交换工具人---------------------------------------------------- PRINT 交换工具人 500 #拿出孵蛋宝可梦 FOR 3 X 50 50 NEXT 3000 UP 200 FOR 5 50 A 100 50 NEXT 2000 L 200 500 RIGHT _拿取延时 200 Y 200 300 FOR 2 100 LEFT _拿取延时 100 NEXT 300 FOR 2 100 DOWN _拿取延时 100 NEXT 200 A 100 200 UP _拿取延时 300 MINUS 300 FOR 5 UP 50 NEXT 100 A 100 200 RIGHT _拿取延时 200 A 100 200 R 200 500 PRINT 交换已完成 ENDIF #自动孵蛋----------------------------------------------------- $1 = 1 #列数 1为第一列，不要修改 $2 = 1 #已孵蛋箱数 $3 = _孵蛋周期 $3 *= 3 $3 /= 2 $3 += _孵蛋延时 $6 = 1 PRINT 开始孵蛋 FOR _孵蛋箱数 FOR 6 #盒子取蛋 500 MINUS 300 FOR 8 DOWN 50 NEXT 100 A 100 200 DOWN _拿取延时 100 FOR $1 100 LEFT _拿取延时 100 NEXT FOR 3 A 100 100 NEXT FOR 13 50 B 100 50 NEXT 1500 #往复式孵蛋---------------------------- LS 90,_往对侧 FOR $3 FOR 10 LS 90 A 50 NEXT FOR 10 LS 270 A 50 NEXT NEXT LS RESET LS 270,4500 #往复式孵蛋---------------------------- 500 #复位 $5 = _复位功能 IF $5 = 1 IF $6 = _复位周期 IF $1 = 6 $6 = 0 LS 180,100 400 L 100 600 LS 90,2000 500 LS 270,_往中心 600 CALL POINT ENDIF ENDIF ENDIF 500 #宝可梦放回盒子 FOR 3 X 50 50 NEXT FOR 5 50 A 100 50 NEXT 2000 DOWN _拿取延时 300 LEFT _拿取延时 300 #自动放生代码【烧录需删除】-------------------------- $5 = _自动放生闪光识别 $4 = 0 IF $5 = 1 PRINT 开始放生 FOR 5 $5 = @LV IF $5 \u0026lt; 95 BREAK ENDIF $5 = @闪光 IF $5 \u0026gt; 95 PRINT 第 \u0026amp; $2 \u0026amp; 箱第 \u0026amp; $1 \u0026amp; 列出闪了!!! DOWN 100 300 $4 += 1 ELSE FOR $5 = @打开菜单 IF $5 \u0026gt; 95 BREAK ELSE A 100 500 ENDIF NEXT FOR $5 = @放生 IF $5 \u0026gt; 95 BREAK ELSE UP 100 200 ENDIF NEXT FOR $5 = @放生2 IF $5 \u0026gt; 95 BREAK ELSE A 100 1200 ENDIF NEXT FOR $5 = @放生3 IF $5 \u0026gt; 95 BREAK ELSE UP 100 400 ENDIF NEXT FOR $5 = @放生4 IF $5 \u0026gt; 95 A 100 1500 ELSE BREAK ENDIF NEXT ENDIF NEXT IF $4 \u0026gt; 0 FOR $5 = @回到第二行 IF $5 \u0026lt; 95 UP 100 200 ELSE BREAK ENDIF NEXT ENDIF ENDIF #自动放生代码--------------------------\tMINUS 300 #闪光识别代码----------------------------------------------------- FOR 8 $5 = _闪光识别 IF $5 = 1 #烧录模式将下行的代码注释掉，在前面加上【#】即可，无采集卡同理 $5 = @闪光 #烧录需将此行注释，如【#$5 = 闪光】 IF $5 \u0026gt; 95 PRINT 第 \u0026amp; $2 \u0026amp; 箱第 \u0026amp; $1 \u0026amp; 列出闪了!!! ENDIF ENDIF DOWN 100 100 NEXT #闪光识别代码----------------------------------------------------- 300 A 100 FOR 3 UP 100 NEXT 300 FOR $1 100 RIGHT _拿取延时 100 NEXT FOR 3 A 100 100 NEXT FOR 3 B 100 100 NEXT 2000 FOR 3 A 50 NEXT 2000 IF $1 != 6 #换下一列 FOR $1 100 RIGHT _拿取延时 100 NEXT ELSE 200 R 100 300 ENDIF PRINT 第 \u0026amp; $2 \u0026amp; 箱第 \u0026amp; $1 \u0026amp; 列已孵完 $1 += 1 NEXT $2 += 1 $6 += 1 $1 = 1 NEXT PRINT 结束 5 进阶操作 你可以购买一个采集卡，然后自制标签，这样就可以使用图像识别了。\n6 结语 使用EasyCon和相关的开发板为Nintendo Switch玩家提供了一种便捷、经济的方式来自定义并模拟控制器的操作。无论你是希望为特定游戏创建自定义的宏，还是希望进行更复杂的操作，本教程为你提供了开始的基础。\n","date":"2023-08-28T15:43:40+08:00","image":"https://cdn.hluvmiku.tech/blog/202308281657027.JPG","permalink":"https://hluvmiku.tech/blog/nintendo-switch-joycon-simulator/","title":"Nintendo Switch Joycon Simulator"},{"content":" Note\n本文章是 使用hugo+GitHub Pages搭建免费博客 的续篇。\n下文假设你已经：\n拥有自己的GitHub Pages仓库 安装了hugo并完成有关配置 1 前言 通过这篇文章，你将获得以下方案：\n使用Git与GitHub备份全站 使用GitHub Actions自动部署全站 使用自定义域名 2 使用Git与GitHub备份全站 2.1 初始化Git 在GitHub上创建一个新的private仓库，仓库名为 blogName 。 Warning\n请务必设置为private仓库，否则你的配置文件中的私密信息将会被公开。\n在你的站点目录下执行以下命令：\n1 2 3 4 5 git init git remote add origin \u0026lt;your-repo-url\u0026gt; git add . git commit -m \u0026#34;init\u0026#34; git push -u origin master 2.2 配置.gitignore 在你的站点目录下创建 .gitignore 文件，内容如下：\n1 /public 这可以防止你的 public 目录被提交到仓库中。\n3 使用GitHub Actions自动部署全站 3.1 创建GitHub Actions 在你的站点目录下创建 .github/workflows/gh-pages.yml 文件，内容如下：\n点击查看配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 # Sample workflow for building and deploying a Hugo site to GitHub Pages name: Deploy Hugo site to Pages on: # Runs on pushes targeting the default branch push: branches: [\u0026#34;main\u0026#34;] # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages permissions: contents: read pages: write id-token: write # Environment variables available to all jobs and steps in this workflow env: HUGO_ENV: production HUGO_VERSION: \u0026#34;0.115.4\u0026#34; GO_VERSION: \u0026#34;1.20.5\u0026#34; NODE_VERSION: \u0026#34;18.15.0\u0026#34; TINA_CLIENT_ID: ${{ vars.TINA_CLIENT_ID }} TINA_TOKEN: ${{ vars.TINA_TOKEN }} jobs: # Build job build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Set up Node.js uses: actions/setup-node@v3 with: node-version: ${{ env.NODE_VERSION }} - name: Install Hugo run: | curl -LO \u0026#34;https://github.com/gohugoio/hugo/releases/download/v${{ env.HUGO_VERSION }}/hugo_extended_${{ env.HUGO_VERSION }}_Linux-64bit.tar.gz\u0026#34; tar -xvf hugo_extended_${{ env.HUGO_VERSION }}_Linux-64bit.tar.gz sudo mv hugo /usr/local/bin/ rm hugo_extended_${{ env.HUGO_VERSION }}_Linux-64bit.tar.gz hugo version - name: Install Go run: | curl -LO \u0026#34;https://dl.google.com/go/go${{ env.GO_VERSION }}.linux-amd64.tar.gz\u0026#34; sudo tar -C /usr/local -xzf go${{ env.GO_VERSION }}.linux-amd64.tar.gz echo \u0026#34;export PATH=$PATH:/usr/local/go/bin\u0026#34; \u0026gt;\u0026gt; $GITHUB_ENV rm go${{ env.GO_VERSION }}.linux-amd64.tar.gz go version - name: Setup Project run: npm run project-setup - name: Install npm dependencies run: npm install - name: Build Website run: npm run build - name: Upload artifact uses: actions/upload-pages-artifact@v1 with: path: ./public - name: Echo CNAME run: echo ${{ secrets.CNAME }} \u0026gt; ./public/CNAME - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} EXTERNAL_REPOSITORY: ${{ secrets.PAGE_URL }} PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} 仔细观察代码，你会发现有一些变量需要你自己填写。\n3.2 配置GitHub Secrets 在你的仓库中，点击 Settings -\u0026gt; Secrets -\u0026gt; New repository secret ，添加以下变量：\nPERSONAL_TOKEN\n这是你的GitHub Personal Token，用于推送到仓库中。\n点击这里获得你的Token。 PAGE_URL\n这是你的GitHub Pages仓库的URL，格式应该为 username.github.io 。 CNAME(可选)\n这是你的自定义域名，格式应该为 example.com 。 点击查看示例 3.3 部署博客 观察GitHub Actions的配置文件，你会发现，只有在main分支提交时，才会触发自动部署。\n1 2 3 4 5 6 7 # Sample workflow for building and deploying a Hugo site to GitHub Pages name: Deploy Hugo site to Pages on: # Runs on pushes targeting the default branch push: branches: [\u0026#34;main\u0026#34;] 因此，我们需要将静态文件推送到main分支中就能完成部署。\n1 2 3 git add . git commit -m \u0026#34;init\u0026#34; git push origin main 或者在GitHub网页中编辑完文章后，点击Commit changes按钮。\n这样，你应该就能在username.github.io中看到你的博客了。\n4 （可选）使用自定义域名 如果你想要绑定域名，可以在 GitHub Pages 的设置中，将 Custom domain 设置为你的域名。\n此外，你还需要在你的域名服务商中，添加一条 CNAME 记录，将 yourCustom.domain 指向你的博客域名username.github.io。 Tip\n有时，你或许需要在你的域名服务商中，添加一条 A 记录，将 yourCustom.domain 指向 GitHub对应的IP地址。\n这样你就可以通过yourCustom.domain访问你的博客了。\n5 结语 至此，你的博客就已经可以自动部署了。\n下一篇文章中，我将分享我将博客文章图片托管至OSS的方案。\n","date":"2023-08-28T14:35:20+08:00","image":"https://cdn.hluvmiku.tech/blog/202308281503218.png","permalink":"https://hluvmiku.tech/blog/build-your-blog-2/","title":"Build Your Blog 2"},{"content":"1 前言 Note\n注意：我并不推荐这套方案，比起这套方案，hexo + GitHub Pages有着更加完善的生态。\n如果说是使用托管服务搭建博客的话，其实我并不是很建议 hugo 。\nhugo 相较于 hexo 来说，配置起来比较麻烦，而且 hugo 的主题插件也比较少。\n它的优势在哪呢？它的唯一优势是生成速度快。但是既然都使用托管服务了，那么生成速度就不在我们的考量中。\n那么为什么我还是使用 hugo 呢？\n单纯是因为我一开始是想部署到自己服务器上的，后来才发现部署到 GitHub Pages 上更方便。\n2 安装hugo 首先安装 Go。\nmacOS Linux Windows 1 brew install go 1 sudo apt install golang-go 下载地址\n安装完成后，执行 go version 查看是否安装成功。\n接下来去GitHub的release页面下载 hugo 的二进制文件。\n下载地址\n或者，如果你使用的是 MacOS ，可以直接使用 brew 安装。\n1 brew install hugo 根据 README.md 安装即可。\n安装完成后，使用 hugo new site blogName 创建一个新的站点。\n3 配置hugo与挑选主题 Note\n每个主题的配置文件都略微有区别，本文只挑选共性的部分进行讲解。\n我使用的是 hugoplate 主题，其他主题也大同小异。\n你可以在这里挑选你喜欢的主题。\n并按照它的文档进行安装。\n安装完主题后，我们需要配置 config.toml 文件。\n（在 hugoplate 主题中，配置文件是 hugo.toml ，其他主题可能是 config.toml ）\n首先我们按照需求填写基本信息。 baseURL 部分可以等创建完GitHub Pages后再进行填写。\n1 2 3 4 5 6 7 baseURL = \u0026#34;https://hluvmiku.tech\u0026#34; # Title of your website (required). title = \u0026#34;HaleyCH\u0026#39;s Blog\u0026#34; # Your theme name theme = \u0026#34;hugoplate\u0026#34; # Default time zone for time stamps; use any valid tz database name: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List timeZone = \u0026#34;Asia/Shanghai\u0026#34; 其中theme修改为你使用的主题名称。\nNote\n请务必配置 baseURL ，否则你的网站将无法正常访问。\n下方内容按需配置：\n配置语言与多国语 Tip\n不建议使用多国语言，虽然hugo原生支持多国语言，但是多国语生成的sitemap会不被某些搜索引擎接受。\n在 hugoplate 主题中，语言与目录配置文件在 config/_default 目录下。\n若要支持多国语，只需修改 languages.toml 文件即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 ################ English language ################## [en] languageName = \u0026#34;english\u0026#34; languageCode = \u0026#34;en\u0026#34; contentDir = \u0026#34;content/en\u0026#34; weight = 1 ################ Chinese language ################## # [zh] # languageName = \u0026#34;中文\u0026#34; # languageCode = \u0026#34;zh\u0026#34; # contentDir = \u0026#34;content/en\u0026#34; # weight = 1 其中languageCode为语言代码，contentDir为语言对应的内容目录。\n他们分别同目录下的menus.en.toml和 content 目录下的 en 目录对应。\n若要修改目录对应的翻译，则需修改对应语言的 menus.toml 文件。\n如果有i18n目录，则需修改 i18n 目录下对应语言的 toml 文件。\n定制你的博客 Note\n这一块不同主题差距比较大，我只我对 hugoplate 主题的配置为例。\n我先对config/_default目录下params.torml文件进行配置。\n1 2 3 4 5 6 7 favicon = \u0026#34;images/favicon.png\u0026#34; # 网站图标 logo = \u0026#34;\u0026#34; # logo 由于我没有，故为空。 logo_darkmode = \u0026#34;\u0026#34; # theme-mode theme_switcher = true theme_default = \u0026#34;system\u0026#34; # available options [light/dark/system] copyright = \u0026#34;Made with ❤️ by Haley.\u0026lt;br\u0026gt;Since 2023\u0026#34; # copyright 以上是基础的网站信息配置，下面是一些SEO配置。\n1 2 3 4 5 6 # seo meta data for OpenGraph / Twitter Card [metadata] keywords = [\u0026#34;technology\u0026#34;, \u0026#34;blog\u0026#34;] description = \u0026#34;Hugo \u0026amp; Tailwindcss Starter\u0026#34; author = \u0026#34;HaleyCH\u0026#34; image = \u0026#34;images/og-image.png\u0026#34; 接下来，根据主题中使用的插件不同，可能在data目录下也会有部分配置，这部分我不做讲解。\n此外，如果你想要修改主题的样式，可以在 assets 目录下进行修改。\n定制化你的文章 在 hugo 中，文章通过 hugo new 命令创建。\n1 hugo new posts/your-post-name.md 这样就创建了一篇文章，文章的内容在 content/posts/your-post-name.md 中。\n它会查看 archetypes 目录下的 default.md 文件，将其内容执行并复制到新建的文章中。\n下面是一个例子：\n1 2 3 4 5 6 --- title_zh: \u0026#34;\u0026#34; title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} draft: true --- 我将会另外写一篇文章讲解利用 hugo 的 archetypes 实现类似 hexo 的 abbrlink 功能。\n4 使用GitHub Pages部署免费博客 4.1 创建GitHub Pages 首先，我们需要创建一个仓库，仓库名必须为 username.github.io ，其中 username 为你的用户名。\n这样，GitHub Pages就会自动为你创建一个网站。\nNote\n现在GitHub Pages已经可以在所有仓库中创建了，但是我还是建议使用 username.github.io 的方式。\n因为这样可以不用自己申请域名。\n你可以在这里查看GitHub Pages配置情况 4.2 部署博客 首先，我们需要在本地生成静态文件。 1 hugo 这样就会在 public 目录下生成静态文件。 2. 接下来，我们需要设置远程仓库。\n1 2 3 4 cd public git init git remote add origin git pull origin master 最后，我们将静态文件推送到远程仓库。 1 2 3 git add . git commit -m \u0026#34;init\u0026#34; git push origin master 在 GitHub Pages 的设置中，将 Source 设置为 master branch 。 等待一段时间后，你的博客就会部署成功了。访问地址为 https://username.github.io 。 4.3 （可选）绑定域名 如果你想要绑定域名，可以在 GitHub Pages 的设置中，将 Custom domain 设置为你的域名。\n然后，在你的域名服务商中，添加一条 CNAME 记录，将 username.github.io 指向你的域名。 即可完成绑定。\n5 结语 至此，你的博客就已经部署成功了。\n不过它存在以下几点问题：\n操作繁琐，每次写完文章都需要手动执行一系列命令。 备份同步麻烦。 这些问题将会在我的下一篇博客中解决。\n在下一篇博客中，我将详细讲解利用GitHub Action自动部署的方案，这样你就只需在本地push整个目录，就可以自动部署了。\n","date":"2023-08-28T11:43:57+08:00","image":"https://cdn.hluvmiku.tech/blog/202308281329993.png","permalink":"https://hluvmiku.tech/blog/build-your-blog-1/","title":"Build Your Blog 1"},{"content":"原来的博客发生了什么？ 长话短说，我不小心把之前博客的数据库删了。\n就单纯是一不小心删除了了数据库文件。\n这是什么？ 这是我用 Hugo 搭建的博客，并使用 Github Actions 自动部署。\n所有图片通过 七牛云 储存，本地上传采用了 PicGO。\n全博客本着能用现成的就不造轮子的宗旨。\n感觉比上一个博客舒服多了，具体流程我会在之后的文章中分享。\n封面是什么？ 封面是我无意中翻出去年自己设计的第一款鼠标垫的私货款式，因为不符合某些要求，最后没做出来。\n总之，因祸得福 这是我的第六版博客。\n自己手写了3版，第一版是Django乱做的，第二版是纯三件套搭的，第三版是用Vue3搭的。\n第四版，也就是之前的博客，是用Hexo搭的，部署在自己服务器上，但是被我手抖删除了。\n在这之后的半年里，我试着用wordpress搭建过博客，不尽如人意，然后我又用Vue3写了一个。\n但是我太懒了，感觉也没提升，就搁置了。\n现在的这一版，我放弃了自己手动搭博客，也懒得再在本地搭了。\n托管在GitHub上，用现成的框架，用OSS储存图片，如果不是因为我第四版博客崩了，我也绝对不会接受这套方案。\n现在感觉这套方案很好🥰。\n","date":"2023-08-26T11:27:00Z","image":"https://cdn.hluvmiku.tech/blog/202308272034636.png","permalink":"https://hluvmiku.tech/blog/re%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C/","title":"Re:你好，世界"}]