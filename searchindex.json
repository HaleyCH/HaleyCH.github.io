[{"section":"Blog","slug":"/blog/jms-shared-living-guide/","title":"JMS Shared Living Guide","description":"JMS Shared Living Guide","date":"April 22, 2024","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech/image202404221345251.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"\"\n    width=\"420\" /\u003e\n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech/image202404221345251.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"100\"\n    width=\"100\" /\u003e\n","searchKeyword":"","categories":"文档","tags":"JMS","content":" Tip\n本文档仅供JMS拼车成员使用。\nNote\n在操作时如遇任何问题，请联系我🥰。\n必看 ⚠️ 规则：每月26日到月末进行拼车线路统计，次月第一个星期根据统计人数平摊费用进行支付，在这期间可正常使用订阅。 ‼️ 也就是说：未在统计期间及时进行统计，会导致本月人均费用变高，请及时统计\n（虽然我会在下个月总价里将这个月超收部分减去，让大家合计花费不变，但还是麻烦）\n指南 一图流指南 统计篇\n先于统计界面选择线路、填写token，和之前问卷星是一样的。 口令类似于网站密码，会在群里发，填入就行了 于25日至月末提交统计结果 支付篇\n进入支付界面 填入你的token与网站口令（token会自动保存，不用怕忘记） 点击提交，会在右侧出现支付二维码 支付，然后就能使用了 常见疑问 没时间写了，考研复习要紧。\n"},{"section":"Blog","slug":"/blog/postgraduate-exam-wallpaper/","title":"Postgraduate Exam Wallpaper","description":"分享一些自制的考研壁纸。","date":"April 18, 2024","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech/image202404181135472.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"\"\n    width=\"420\" /\u003e\n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech/image202404181135472.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"100\"\n    width=\"100\" /\u003e\n","searchKeyword":"","categories":"考研, 学习","tags":"考研, 壁纸","content":" Tip\n不定期更新 上次更新时间：2024-04-18\nNote\n本壁纸尺寸仅适配了iPhone13/14数字系列。\n部分考研壁纸分享 考研壁纸下载 （推荐使用）考研壁纸-百度网盘，提取码hluv，最后更新于2024-04-18 考研壁纸-figma项目，实时更新 考研壁纸，与其他考研资料-美区icloud链接，实时更新 （备份下载）考研壁纸-本站下载，最后更新与于2024-04-18 "},{"section":"Blog","slug":"/blog/build-sysy-lex-analyzer-with-flex/","title":"Build SysY Lex Analyzer With FLex","description":"本文介绍了FLex基本语法并提供了一个最小实践。之后提供了FLex搭建SysY词法分析器的具体方法。","date":"December 5, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech//image/202312051936450.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"\"\n    width=\"420\" /\u003e\n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech//image/202312051936450.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"100\"\n    width=\"100\" /\u003e\n","searchKeyword":"","categories":"学习","tags":"compiler, gcc, GNU, FLex, SysY","content":" 目录 前言 GNU FLex 介绍 FLex安装与初步使用 FLex语法浅析 SysY介绍 实现 definitions部分 rules部分 user subrouting部分 完整代码 总结 Tip\n通过本文，你将了解：\nFLex基本操作 如何通过FLex编写一个简单的词法分析器 Note\n此词法分析器将作为一个语法分析器的部分，因此输出仅为一系列的Token与值，并不执行其他操作。\n此外，本词法分析器基于SysY语法，它是c语言的一个子集。\n本文将收录于杭电编译原理实验报告\n前言 GNU FLex 介绍 点击查看FLex介绍 Flex的前身是Lex。Lex是1975年由Mike Lesk和当时还在AT\u0026amp;T做暑期实习的Eric Schmidt，共同完成的一款基 于Unix环境的词法分析程序生成工具。虽然Lex很出名并被广泛 使用，但它的低效和诸多问题也使其颇受诟病。后 来伯克利实验室的Vern Paxson使用C语言 重写Lex，并将这个新的程序命名为Flex(意为Fast Lexical Analyzer Generator)。无论在效 率上还是在稳定性上，Flex都远远好于它的前辈Lex。我们在Linux下使用的是Flex在GNU License下的版本，称作GNU Flex。\nFLex安装与初步使用 在Linux中，安装FLex十分简单，只需要sudo apt-get install flex即可。\n然后我们创建一个新文件scanner.l，并在其中输入以下内容：\n%% [0-9]+ printf(\u0026#34;?\u0026#34;); # return 0; . ECHO; %% int main(int argc, char* argv[]) { yylex(); return 0; } int yywrap() { return 1; } 使用指令flex scanner.l编译程序，可以看到目录下出现了一个名为 lex.yy.c的文件，我们再使用gcc -o scanner lex.yy.c，即可得到可执行文件./scanner。\n我们试着运行一下./scanner并输入：\n$ ./scanner afeafewa afeafewa 1233 ? aaaa111 aaaa? 可以观察到这段代码将数字部分都替换为了?，其他部分不变。\nFLex语法浅析 在介绍FLex语法前，先解释上文程序工作原理。\n观察代码，可以看到[0-9]+ printf(\u0026quot;?\u0026quot;);，这行代码匹配输入中包含1个或多个数字，接收到数字串后输出一个?。\n程序执行时，逐字读取输入，并自上而下尝试匹配定义的规则，并执行匹配规则后方的代码。\n在本程序中，如果是数字，会被[0-9]+匹配，并输出?，而其它字符将被. ECHO;匹配，输出该字符本身。因此上文的代码才能实现将数字部分都替换为了?，其他部分不变的功能。\nFLex语法可以分为三部分：\n{definitions} %% {rules} %% {user subroutines} 其中definitions部分定义了一系列别名，格式为name definitions。例如br [ \\t]+就是定义br为连续的一个或多个空格或制表符，在rules中，直接可以使用br代替[ \\t]+进行匹配。\n这就使规则定义更加灵活，例如：\nidentifier {identifier-nondigit}({identifier-nondigit}|{identifier-digit})* identifier-digit [0-9] identifier-nondigit [_a-zA-Z] 这就定义了一个identifier应该有的格式：一个非数字符号开头、有0个或多个字符、下划线重复组成的字符串。\nrules部分格式为re/name actions，例如[0-9]+ printf(\u0026quot;?\u0026quot;);，FLex将自上而下对输入字符进行匹配，并执行对应的代码。\n而user subroutines将会被原封不动的复制进入lex.yy.c中，你可以在这里定义一系列自定义函数与main函数。\nSysY介绍 你可以在此处 找到详细的SysY 2022文法的定义。\n实现 Note\n完整代码在完整代码小节中。\n词法分析器接收字符串组序列，输出字符符号序列并识别可能的词法错误，将其交给语法分析器。\n因此，我们在词法分析部分只需简单的用正则表达式匹配字符集中的各种模式和关键词即可。\n由于FLex是自上而下匹配，因此我们可以在末尾使用.通配符匹配所有未在符号集中的单词，并抛出词法错误。\n并且，因为我们还未接入语法分析器（语法分析器部分将收录于编译原理实验四），我们只需简单的打印匹配结果验证词法分析结果即可。\ndefinitions部分 identifier {identifier-nondigit}({identifier-nondigit}|{identifier-digit})* identifier-digit [0-9] identifier-nondigit [_a-zA-Z] br [ \\t]+ rules部分 {br} {;} \u0026#34;/\\*\u0026#34; { char curr,prev; prev = \u0026#39;\\0\u0026#39;; curr = input(); while(prev!=\u0026#39;*\u0026#39;||curr!=\u0026#39;/\u0026#39;) {prev = curr; curr = input();} } \u0026#34;//\u0026#34; { printf(\u0026#34;\u0026lt;COMMENT\u0026gt;\\n\u0026#34;); char curr; curr = input(); while(curr!=\u0026#39;\\n\u0026#39;) curr = input(); } \u0026#34;int\u0026#34; {printf(\u0026#34;\u0026lt;INT\u0026gt;\\n\u0026#34;);} /* 省略部分匹配代码，可在完整代码中查看 */ \u0026#34;}\u0026#34; {printf(\u0026#34;\u0026lt;}\u0026gt;\\n\u0026#34;);} \\n { ++yylineno; } \u0026#34;0\u0026#34;[0-9a-zA-Z]* { int pos = 1; char c,buf[2]; c = yytext[pos++]; if (c!=\u0026#39;x\u0026#39;\u0026amp;\u0026amp;c!=\u0026#39;X\u0026#39;){ int total=0; /* 省略部分进制转换代码，可在完整代码中查看 */ } {identifier} {return IDENTIFIER;} [0-9]+ {printf(\u0026#34;\u0026lt;INTNUM, %d\u0026gt;\\n\u0026#34;,atoi(yytext));} . { printf(\u0026#34;Error at Line %d: Invalid characters \\\u0026#39;%s\\\u0026#39;\\n\u0026#34;, yylineno, yytext); } 可以看到，对于大部分内容，仅仅是简单的匹配并输出，而对于整型数字，则需要将其解析为10进制值并输出。\n值得注意的是，为了实现词法分析以及之后工作的结果与行号对应，我们在匹配到回车符时将yylineno加一\\n { ++yylineno; }。yylineno是FLex定义的一个全局变量，代表当前处理行号。\nuser subrouting部分 int main(int argc, char** argv) { if (argc \u0026gt; 1) { yyin = fopen(argv[1], \u0026#34;r\u0026#34;); if (!yyin) { perror(\u0026#34;Error opening file\u0026#34;); return 1; } } else { printf(\u0026#34;Usage: %s \u0026lt;filename\u0026gt;\\n\u0026#34;, argv[0]); return 1; } while (yylex() != 0); fclose(yyin); return 0; } int yywrap() { return 1; } 这部分实现了从文件读取代码。\n完整代码 点击此处查看完整代码 identifier {identifier-nondigit}({identifier-nondigit}|{identifier-digit})* identifier-digit [0-9] identifier-nondigit [_a-zA-Z] br [ \\t]+ %% {br} {;} \u0026#34;/\\*\u0026#34; { printf(\u0026#34;\u0026lt;COMMENT\u0026gt;\\n\u0026#34;); char curr,prev; prev = \u0026#39;\\0\u0026#39;; curr = input(); while(prev!=\u0026#39;*\u0026#39;||curr!=\u0026#39;/\u0026#39;) {prev = curr; curr = input();} } \u0026#34;//\u0026#34; { printf(\u0026#34;\u0026lt;COMMENT\u0026gt;\\n\u0026#34;); char curr; curr = input(); while(curr!=\u0026#39;\\n\u0026#39;) curr = input(); } \u0026#34;int\u0026#34; {printf(\u0026#34;\u0026lt;INT\u0026gt;\\n\u0026#34;);} \u0026#34;float\u0026#34; {printf(\u0026#34;\u0026lt;FLOAT\u0026gt;\\n\u0026#34;);} \u0026#34;void\u0026#34; {printf(\u0026#34;\u0026lt;VOID\u0026gt;\\n\u0026#34;);} \u0026#34;if\u0026#34; {printf(\u0026#34;\u0026lt;IF\u0026gt;\\n\u0026#34;);} \u0026#34;else\u0026#34; {printf(\u0026#34;\u0026lt;ELSE\u0026gt;\\n\u0026#34;);} \u0026#34;while\u0026#34; {printf(\u0026#34;\u0026lt;WHILE\u0026gt;\\n\u0026#34;);} \u0026#34;break\u0026#34; {printf(\u0026#34;\u0026lt;BREAK\u0026gt;\\n\u0026#34;);} \u0026#34;return\u0026#34; {printf(\u0026#34;\u0026lt;RETURN\u0026gt;\\n\u0026#34;);} \u0026#34;+\u0026#34; {printf(\u0026#34;\u0026lt;ADD\u0026gt;\\n\u0026#34;);} \u0026#34;-\u0026#34; {printf(\u0026#34;\u0026lt;SUB\u0026gt;\\n\u0026#34;);} \u0026#34;*\u0026#34; {printf(\u0026#34;\u0026lt;MUL\u0026gt;\\n\u0026#34;);} \u0026#34;/\u0026#34; {printf(\u0026#34;\u0026lt;DIV\u0026gt;\\n\u0026#34;);} \u0026#34;%\u0026#34; {printf(\u0026#34;\u0026lt;MOD\u0026gt;\\n\u0026#34;);} \u0026#34;!\u0026#34; {printf(\u0026#34;\u0026lt;NOT\u0026gt;\\n\u0026#34;);} \u0026#34;,\u0026#34; {printf(\u0026#34;\u0026lt;,\u0026gt;\\n\u0026#34;);} \u0026#34;=\u0026#34; {printf(\u0026#34;\u0026lt;=\u0026gt;\\n\u0026#34;);} \u0026#34;;\u0026#34; {printf(\u0026#34;\u0026lt;;\u0026gt;\\n\u0026#34;);} \u0026#34;\u0026gt;=\u0026#34; {printf(\u0026#34;\u0026lt;GE\u0026gt;\\n\u0026#34;);} \u0026#34;\u0026lt;=\u0026#34; {printf(\u0026#34;\u0026lt;LE\u0026gt;\\n\u0026#34;);} \u0026#34;==\u0026#34; {printf(\u0026#34;\u0026lt;EQ\u0026gt;\\n\u0026#34;);} \u0026#34;!=\u0026#34; {printf(\u0026#34;\u0026lt;NE\u0026gt;\\n\u0026#34;);} \u0026#34;\u0026gt;\u0026#34; {printf(\u0026#34;\u0026lt;GT\u0026gt;\\n\u0026#34;);} \u0026#34;\u0026lt;\u0026#34; {printf(\u0026#34;\u0026lt;LT\u0026gt;\\n\u0026#34;);} \u0026#34;||\u0026#34; {printf(\u0026#34;\u0026lt;OR\u0026gt;\\n\u0026#34;);} \u0026#34;\u0026amp;\u0026amp;\u0026#34; {printf(\u0026#34;\u0026lt;AND\u0026gt;\\n\u0026#34;);} \u0026#34;(\u0026#34; {printf(\u0026#34;\u0026lt;(\u0026gt;\\n\u0026#34;);} \u0026#34;)\u0026#34; {printf(\u0026#34;\u0026lt;)\u0026gt;\\n\u0026#34;);} \u0026#34;[\u0026#34; {printf(\u0026#34;\u0026lt;[\u0026gt;\\n\u0026#34;);} \u0026#34;]\u0026#34; {printf(\u0026#34;\u0026lt;]\u0026gt;\\n\u0026#34;);} \u0026#34;{\u0026#34; {printf(\u0026#34;\u0026lt;{\u0026gt;\\n\u0026#34;);} \u0026#34;}\u0026#34; {printf(\u0026#34;\u0026lt;}\u0026gt;\\n\u0026#34;);} \\n { ++yylineno; } \u0026#34;0\u0026#34;[0-9a-zA-Z]* { int pos = 1; char c,buf[2]; c = yytext[pos++]; if (c!=\u0026#39;x\u0026#39;\u0026amp;\u0026amp;c!=\u0026#39;X\u0026#39;){ int total=0; while (c\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;c\u0026lt;=\u0026#39;7\u0026#39;){ if (c\u0026gt;\u0026#39;9\u0026#39;||c\u0026lt;\u0026#39;0\u0026#39;){ printf(\u0026#34;Error at Line %d: Invalid characters \\\u0026#39;%s\\\u0026#39;\\n\u0026#34;, yylineno, yytext); return -1; } buf[0]=c; buf[1]=\u0026#39;\\0\u0026#39;; total = total*8+atoi(buf); c = yytext[pos++]; } if (c!=\u0026#39; \u0026#39;\u0026amp;\u0026amp;c!=\u0026#39;\\t\u0026#39;\u0026amp;\u0026amp;c!=\u0026#39;\\n\u0026#39;\u0026amp;\u0026amp;c!=\u0026#39;\\0\u0026#39;){ printf(\u0026#34;Error at Line %d: Invalid octalnumber \\\u0026#39;%s\\\u0026#39;\\n\u0026#34;, yylineno, yytext); return -1; } printf(\u0026#34;\u0026lt;INTNUM, %d\u0026gt;\\n\u0026#34;, total); return 1; } else { c = yytext[pos++]; int total = 0; while ((c\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;c\u0026lt;=\u0026#39;9\u0026#39;)||(c\u0026gt;=\u0026#39;a\u0026#39;\u0026amp;\u0026amp;c\u0026lt;=\u0026#39;f\u0026#39;)||(c\u0026gt;=\u0026#39;A\u0026#39;\u0026amp;\u0026amp;c\u0026lt;=\u0026#39;F\u0026#39;)){ if (c\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;c\u0026lt;=\u0026#39;9\u0026#39;){ total = total*16 + c-\u0026#39;0\u0026#39;; } if (c\u0026gt;=\u0026#39;a\u0026#39;\u0026amp;\u0026amp;c\u0026lt;=\u0026#39;f\u0026#39;){ total = total*16 + c-\u0026#39;a\u0026#39;+10; } if (c\u0026gt;=\u0026#39;A\u0026#39;\u0026amp;\u0026amp;c\u0026lt;=\u0026#39;F\u0026#39;){ total = total*16 + c-\u0026#39;A\u0026#39;+10; } c = yytext[pos++]; } if (c!=\u0026#39; \u0026#39;\u0026amp;\u0026amp;c!=\u0026#39;\\t\u0026#39;\u0026amp;\u0026amp;c!=\u0026#39;\\n\u0026#39;\u0026amp;\u0026amp;c!=\u0026#39;\\0\u0026#39;){ printf(\u0026#34;Error at Line %d: Invalid hex number \\\u0026#39;%s\\\u0026#39;\\n\u0026#34;, yylineno, yytext); return -1; } printf(\u0026#34;\u0026lt;INTNUM, %d\u0026gt;\\n\u0026#34;, total); } } {identifier} {return IDENTIFIER;} [0-9]+ {printf(\u0026#34;\u0026lt;INTNUM, %d\u0026gt;\\n\u0026#34;,atoi(yytext));} . { printf(\u0026#34;Error at Line %d: Invalid characters \\\u0026#39;%s\\\u0026#39;\\n\u0026#34;, yylineno, yytext); } %% int main(int argc, char** argv) { if (argc \u0026gt; 1) { yyin = fopen(argv[1], \u0026#34;r\u0026#34;); if (!yyin) { perror(\u0026#34;Error opening file\u0026#34;); return 1; } } else { printf(\u0026#34;Usage: %s \u0026lt;filename\u0026gt;\\n\u0026#34;, argv[0]); return 1; } while (yylex() != 0); fclose(yyin); // Remember to close the file when done return 0; } int yywrap() { return 1; } 总结 本文实现了一个简单的SysY词法分析器，并且将在下一篇文章中利用Bison+FLex结合此词法分析器进行语法分析器的制作。\n"},{"section":"Blog","slug":"/blog/solve-multi-times-backwards-in-pytorch/","title":"Solve Multi Times Backwards In pytorch","description":"本文提供了torch报错Trying to backward through the graph a second time (or directly access saved tensors after they have already been freed的深入排查解决方案","date":"October 25, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech//image/202310251611268.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"\"\n    width=\"420\" /\u003e\n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech//image/202310251611268.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"100\"\n    width=\"100\" /\u003e\n","searchKeyword":"","categories":"疑难解答, AI","tags":"pytorch, debug, error","content":" 目录 前言 常规检查 继续深入 总结 Tip\n本文提供了torch报错Trying to backward through the graph a second time (or directly access saved tensors after they have already been freed的深入排查解决方案\nNote\n排查方法摘要：\n确认是否在一个iter中多次反向传播 确认是否在多个iters之间没调用optimizer.zero_grad() 可视化并确认是否及时detach()了模型参数 前言 实操pytorch也有几年了，虽然都是兴趣使然的小打小闹，但是各种问题或多或少都碰到过。\n一般来说，绝大多数torch的报错都可以Google到，或者在StackOverflow中找到相关解决方案。\n再不济，也可以去GitHub里相关issue中找到解决方案。\n当然，作为最终武器，我们还有ChatGPT，在现在8k上下文的情况下，基本上可以解决大部分问题。\n但是很不幸，我遇到的是这个错误：\nRuntimeError: Trying to backward through the graph a second time (or directly access saved tensors after they have already been freed). Saved intermediate values of the graph are freed when you call .backward() or autograd.grad(). Specify retain_graph=True if you need to backward through the graph a second time or if you need to access saved tensors after calling backward. 我一共遇到了3次这个问题，我之所以说很不幸，是因为它debug起来极其困难，有的时候还会沦落到不得不可视化计算图的地步。 甚至问GPT，它都只会给我笼统地说检查我是不是backwards了多次什么的，毫无参考性。\n这个错误的意思是说在反向传播过程中，计算图在完成反向传播前就被释放了，导致无法再次反向传播。\n一般来说，我们在训练GAN时比较容易遇到，因为可能会有量要被要被反向传播训练G和D两个网络。这种情况下，就老老实实使用retain_graph=True就好了。\n其他情况请按照下文排查。\n常规检查 废话不多说，再深入研究代码前，先确定是不是由以下错误导致的：\n在一个iter中多次反向传播，即类似： loss.backwards() # do something loss.backwards() 在多个iters之间没调用optimizer.zero_grad()，即类似： for i in range(100): # do something loss.backwards() optimizer.step() 以上这两种情况请自行排查解决。\n继续深入 Note\n先说结论：某些该detach().clone()的地方没有detach().clone()。\n如果不知道是哪里需要detach().clone()，可以看我下方的实践。\n我没犯常规检查中的两个错误，但还是出现了这种问题🤔。\n迫不得已，我继续深入研究。\n我很快定位到问题出现在这一段代码：\n@property def get_xyz_purturbed(self): unc = sample_from_grid(self.grid, self._xyz.to(self._xyz.device).view(-1,3), self.lb, self.ub) noise = torch.normal(0, unc) # pdb.set_trace() noise = noise.to(self._xyz.device) return self._xyz + noise.reshape(*self._xyz.shape[:-1],1) 但是我不知道具体问题出在哪。\n被折磨了好久😩，迫不得已我装了个torchviz，用它的make_dot可视化了一下计算图。\ndot = make_dot(loss) dot.save(f\u0026#39;loss.txt\u0026#39;) *不要在意我画的圈，这是我之前和学长讨论的时候留下来的\n（在线可视化工具地址 ）\n其中，蓝色的方框是requires_grad=True的模型参数，橙色的方框是requires_grad=False的。灰色很显然是backwards的节点。\n因为之前我测试过，能确定问题出在左边部分的计算图，我很快注意到了这里： 可以看到，在这里出现了两个requires_grad=True的模型参数，这就是问题所在了。\n以下是我对这个问题的理解，可能有错误，欢迎指正。\n我认为出现这个问题是因为，一般来说，模型的计算图是类似于树一样的结构（不是很准确，因为非叶子结点之间互相可以连接），根节点是loss，叶子结点是模型参数，而像这样的畸形结构导致torch无法在正确的时机释放计算图，从而导致了这个错误。\n于是我优化了一下代码，将self._xyz（计算图中最顶上那个蓝色方块）detach并复制：\n@property def get_xyz_purturbed(self): unc = sample_from_grid(self.grid, self._xyz.cpu().detach().clone().to(self._xyz.device).view(-1,3), self.lb, self.ub) noise = torch.normal(0, unc) # pdb.set_trace() noise = noise.to(self._xyz.device) return self._xyz + noise.reshape(*self._xyz.shape[:-1],1) 这样就解决了问题。\n可以看看我修改后的计算图： 十分的干净利索。\n总结 多次反向传播是torch中较为棘手的问题，需要对torch的反向传播有一定的理解，并且要能完全明确自己的模型是如何backwards的。通常我们可以通过可视化计算图的方式来快速排查。\n"},{"section":"Blog","slug":"/blog/princlples-of-compiler-experiments/","title":"Princlples of Compiler Experiments","description":"整理我自己的编译原理实验报告","date":"October 24, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech//image/202310241501131.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"\"\n    width=\"420\" /\u003e\n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech//image/202310241501131.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"100\"\n    width=\"100\" /\u003e\n","searchKeyword":"","categories":"学习","tags":"compiler, gcc, GNU","content":" 目录 一些建议 实验2 实验3 Tip\n本文汇总了我的所有编译原理实验报告，仅供参考。\n如有疑问或实验报告有误，可以留言，我会及时修改。\n实验命名以学习通的PDF为准。\n一些建议 建议在Ubuntu环境进行实验，否则会和实验文档有出入。 实验2 实验指南下载地址 实验报告链接 修改时间：2023/10/24 实验3 实验代码链接 修改时间：2023/12/5 "},{"section":"Blog","slug":"/blog/create-your-custom-email-domain-with-icloud-plus/","title":"Create Your Custom Email Domain With ICloud Plus","description":"让iCloud+利用率最大化：利用iCloud+的自定义域名功能，你可以在iCloud中使用自定义域名的邮箱。","date":"October 10, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech//image/202310102031515.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"\"\n    width=\"420\" /\u003e\n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech//image/202310102031515.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"100\"\n    width=\"100\" /\u003e\n","searchKeyword":"","categories":"技术分享, Apple","tags":"技术分享, Apple, iCloud, 互联网","content":" 目录 1. 通过Apple购买自定义域名 2. 或者，你可以使用已有的域名 3. 创建自定义邮箱 4. 总结 Tip\n通过本文，你将了解： - 如何通过iCloud购买自定义域名 - 如何使用iCloud+创建自定义邮箱域名\nNote\n你需要一个非国区的Apple ID并且开通iCloud+服务才能完成本文的实践。\n1. 通过Apple购买自定义域名 Tip\n如果你已经有了自己的域名，可以跳过本节。\n在此处 选择进入自定电子邮件域（若为国区，则访问此处 ,并选择购买新域。 输入你想要的域名，如hluvmiku.info，点击查找选择你喜欢的域名并点击继续。 在CloudFlare完成购买。请使用Apple ID登陆或注册Cloudflare账号。购买完成后，点击返回。 等待片刻，你将看到你的域名已经在iCloud中完成验证。\n2. 或者，你可以使用已有的域名 Tip\n如果你在iCloud中按照上一节的步骤购买了域名，可以跳过本节。\n在此处 选择进入自定电子邮件域（若为国区，则访问此处 ,并选择添加您拥有的域并输入你的域名。 在下图所示的位置选择无电子邮件地址，我们将在下一节中创建自定义邮箱。 点击第三步的视图，并根据它所提供的信息在你的域名服务商中添加TXT记录、MX记录与CNAME记录。 完成配置后，单击第四步的验证，等待片刻，你将看到你的域名已经在iCloud中完成验证。\n3. 创建自定义邮箱 按下图即可创建自定义邮件。 4. 总结 至此，你已经完成了自定义域名的购买与配置，你可以在iCloud中使用自定义域名的邮箱了。\n另外，若你是在iCloud中通过Cloudflare购买的域名，也可以用自己的ID登陆Cloudflare管理你的域名。\n"},{"section":"Blog","slug":"/blog/use-llm-in-your-console/","title":"Use LLM in Your Console","description":"本文介绍了Open Interpreter - 一个可以在终端调用GPT-4或本地的Code-llama的python库。","date":"September 13, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech//image/202309131725183.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"\"\n    width=\"420\" /\u003e\n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech//image/202309131725183.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"100\"\n    width=\"100\" /\u003e\n","searchKeyword":"","categories":"技术分享, AI, 推荐","tags":"python, GPT, AI, LLM, llama, OpenAI, Open Interpreter","content":" 目录 1. 为什么选择 Open Interpreter？ 2. 安装与运行 3. Open Interpreter可以做什么？ 将一个目录下所有.mobi文件转化为pdf 4. 进阶用法 Tip\n本文将介绍Open Interpreter - 一个可以在终端调用GPT-4或本地的Code-llama的python库。\nNote\n点击此处 查看官方中文文档。 👇官方宣传视频👇 1. 为什么选择 Open Interpreter？ 前段时间，OpenAI 发布了Code Interpreter，旨在给GPT提供一个有生命周期的notebook与一定的储存、运算资源与一个和用户传输文件的方式。它的问世在极大程度上便利了我的日常代码生活。我曾让它在不知道.pt模型结构的情况下，让它自行搭建模型以读取预训练好的checkpoint，也让他帮我统计过excel报表。可以说它是一个非常强大的工具。\n但，随着使用的深入，问题也逐渐暴露。\n先是我的excel中有部分敏感信息，这使我不得不在本地先进行脱敏处理，再上传给GPT统计报表，极大的影响了效率。\n再是，传输大文件极其依赖网络环境，如果我有一个2.5GB的文件要给Code Interpreter分析，我不得不等待很久。\n此外，OpenAI对其运行时长、内存、存储等资源都有一定的限制，这使得我无法在Code Interpreter上进行一些复杂的操作。\n最后，Code Interpreter依赖于预装好的一系列python库，并且不能联网，这极大的限制了它的使用场景。\n因此我选择了Open Interpreter，它可以在本地运行，可以联网，可以使用本地的所有python库，可以使用本地的所有资源，可以使用本地的所有文件，可以使用本地的所有命令行工具。\n一言以蔽之，你能在终端执行什么操作，Open Interpreter就能在终端执行什么操作，GPT能完成什么操作，它也能一样完成。并且，它可以调用本地或者Azure上的LLM模型以保证隐私。 2. 安装与运行 Tip\n推荐将其装在虚拟环境中，如果你打算长期使用，可以将此虚拟环境作为默认环境。\n我在一个常用的conda虚拟环境中进行安装，这个环境是我最常使用的环境。\nconda activate your_env pip install interpreter 安装完成后，你可以在终端中通过interpreter命令方便的调用它。 Tip\n第一次运行可能需要使用interpreter -y以提供权限。\n3. Open Interpreter可以做什么？ 正如它所说，它能进行文件管理、数据处理、网页抓取、系统操作、编码、自动化等等。\n点击查看原文 \u0026gt; what can you do? As an Open Interpreter, I can execute a wide range of tasks by running code on your machine. Here are some examples of what I can do: 1 File Management: I can create, read, update, and delete files on your system. I can also move files around and organize them into directories. 2 Data Processing: I can read and process data from various sources such as databases, APIs, and files. I can perform operations like filtering, sorting, aggregating, and transforming this data. 3 Web Scraping: I can fetch data from websites by parsing HTML and extracting the information you need. 4 System Operations: I can execute system commands, install software, and manage system processes. 5 Coding: I can write and execute code in various languages like Python, JavaScript, Shell, AppleScript, and HTML. 6 Automation: I can automate repetitive tasks on your computer. Please note that any code I run is executed on your machine with your full and complete permission. I\u0026#39;m here to help, so let me know what you need! 下面我将放一个我亲身经历的几个例子：\n将一个目录下所有.mobi文件转化为pdf 我举一个简单的例子：我想将一个目录下所有.mobi文件转化为pdf。\n让我们看看Open Interpreter的表现。\n\u0026gt; 将/Users/haleyc/Downloads/FIRE\\ PUNCH\\ 炎拳 中的mobi转化为pdf Sure, I can help with that. We will use a tool called Calibre, which is a powerful and easy to use e-book manager. It can convert from a huge number of formats to a huge number of formats, including from MOBI to PDF. Here is the plan: 1 Check if Calibre is installed on your system. 2 If not, install Calibre. 3 Use Calibre\u0026#39;s command-line tools to convert the MOBI file to PDF. Let\u0026#39;s start with the first step, checking if Calibre is installed. calibre --version Would you like to run this code? (y/n) 首先，它会告诉你它的解决方案，然后询问你是否同意。\n它计划先确定是系统否安装了Calibre，如果没有，通过homebrew安装，这之后再进行转码。\n在实际执行过程中，由于网络中断，我只能通过输入继续按照最初计划让它继续执行。\n由于Calibre需要手动配置，我不得不手动配置完毕后再次执行。在配置完后，一切就变得十分顺利。\n点击查看效果图 4. 进阶用法 使用Azure：interpreter --use-azure 使用本地LLM：interpreter --local 使用GPT-3.5-turbo：interpreter --fast 此外，你也可以在python中以库的形式调用它。在此我不做介绍。\n"},{"section":"Blog","slug":"/blog/screenshot-to-reminders/","title":"Screenshot to Reminders","description":"本文提供了一个将截屏转换为提醒事项的解决方案。具体来讲，它将截屏中的文本提取出来，经过GPT整合后，转换为提醒事项。","date":"September 12, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech/blog/202309121546372.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"\"\n    width=\"420\" /\u003e\n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech/blog/202309121546372.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"100\"\n    width=\"100\" /\u003e\n","searchKeyword":"","categories":"技术分享, Apple","tags":"快捷指令, OCR, GPT, iOS, Apple","content":" 目录 1 前言 快捷指令 什么是快捷指令？ 快捷指令可以做什么？ 如何创建快捷指令？ 为什么选择快捷指令？ ChatGPT for iOS 实现方案 截屏+OCR GPT 提醒事项 完整快捷指令流程和代码 Tip\n通过本文，你将了解：\niOS快捷指令的基本使用 如何利用快捷指令中OCR和ChatGPT for iOS将截图文字转换为提醒事项 你将得到视频所示的解决方案：\n点击查看视频 Note\n注意，你必须要能正常访问ChatGPT for iOS，否则无法使用本文中的快捷指令。\n完整的快捷指令可以在文末获取。\n1 前言 本人是一个彻头彻底的懒人，所以我一直在寻找能够提高效率的方法。\n很多时候我会遇到一些突发的事情预约，通常是以通知或者聊天的形式发送给我的。\n自己手动将其输入到提醒事项中，不免显得麻烦，一般情况下我就懒得手动去添加。\n而通知形式又五花八门，也不适合写一个死的程序用一些固定的pattern去匹配。\n因此我自然而然的想到了OCR+GPT的方案。\n而快捷指令正好提供了一套完备的调用方案，于是一切都变得水到渠成了。\n快捷指令 快捷指令是在iOS 12中引入的，它可以让你在不编写代码的情况下，通过拖拽的方式来创建一个自动化的工作流。\n经过多年的发展，快捷指令已然成为 Apple 生态的一大「神器」，配合上第三方应用的支持，它可以替你省下很多不必要的时间，极大地提升工作效率。\n下图为一个简单的快捷指令工作流： 什么是快捷指令？ 快捷指令是一种允许用户在 iOS 设备上自动执行一系列任务的工具。它的目的是简化和自动化日常任务，从而提高效率。用户可以创建自己的快捷指令，也可以从快捷指令图书馆中选择预先创建的快捷指令。\n快捷指令可以做什么？ 日常任务自动化：例如，设置一个“上班模式”，当你到达办公室时，它可以自动打开你的工作应用、设置手机为静音并连接到办公室的 Wi-Fi。 与第三方应用集成：许多第三方应用都支持快捷指令，这意味着你可以创建自动化工作流程，涉及多个应用的操作。 语音控制：与 Siri 集成，允许用户通过语音命令执行快捷指令。 Web 任务自动化：例如，自动下载某个网站的所有图片或将网页内容保存到你的笔记应用中。 文本操作：自动格式化文本、翻译文本或提取文本中的特定信息。 健康和健身：例如，自动记录你的饮食、锻炼或睡眠数据。 家庭自动化：与 HomeKit 集成，允许用户自动控制家中的智能设备。 如何创建快捷指令？ 打开“快捷指令”应用。 点击“创建个人快捷指令”。 选择你想要的动作并将其拖放到工作流程中。 为你的快捷指令命名并保存。 为什么选择快捷指令？ 它集成在 iOS系统中，可以便捷的调用iOS提供的众多功能，也能被如Siri、快捷手势等触发。 低代码、编写方便。 多端同步，你可以在iPhone、iPad、Mac上同步你的快捷指令。 便于分享，你可以将你的快捷指令分享给其他人，也可以从其他人那里获取快捷指令。 ChatGPT for iOS 这是 ChatGPT for iOS的App Store链接，你可以在这里下载它。\n它提供了一个快捷指令，你可以通过它免费调用GPT 3.5，因此你可以用它来实现一些有趣的功能。\n在本文中，我将使用它提供的快捷指令来分析OCR出来的文本，并将其转换为提醒事项。\n实现方案 具体流程已经显而易见了：手动截屏 -\u0026gt; OCR -\u0026gt; GPT -\u0026gt; 提醒事项。\n那我们该如何实现呢？快捷指令已经提供了全部的接口，我们只需要将它们串联起来即可。\n截屏+OCR 我们假设用户是在手动截屏以后立刻调用快捷指令的，因此我们需要在快捷指令中获取最近的一张截屏。 获取截屏的方式有很多种，这里我使用了最简单的方式：获取最近的照片。 获取完截屏以后，我们需要将其传递给OCR，这里我们使用了OCR快捷指令。 具体如下：\n点击查看解决方案 ![202309121529215](https://cdn.hluvmiku.tech/blog/202309121529215.png) GPT 对于GPT，我们需要准备一段固定的文本作为Prompt，并拼接上OCR的输出作为输入。此处我们可以采用快捷指令中的文本与合并文本实现。下面是我的实现方案：\n点击查看解决方案 提醒事项 最后，我们将其转换为提醒事项即可。\n点击查看解决方案 ![202309121540354](https://cdn.hluvmiku.tech/blog/202309121540354.png) 完整快捷指令流程和代码 Note\n注意，你必须要能正常访问ChatGPT，否则无法使用下方的快捷指令。\n点击这里 获得完整的快捷指令。\n"},{"section":"Blog","slug":"/blog/how-to-enable-google-search-console-api/","title":"How to Enable Google Search Console API","description":"本文详细介绍了如何在 Google Cloud Platform 上启用 Google Search API，包括创建项目、验证域名所有权、配置服务号等步骤。","date":"August 29, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech/blog/202308301902385.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"\"\n    width=\"420\" /\u003e\n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech/blog/202308301902385.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"100\"\n    width=\"100\" /\u003e\n","searchKeyword":"","categories":"技术分享, 教程","tags":"Google Cloud Platform, API, 教程, Google Search Console API, Google Indexing API","content":" 目录 1 前言 2 Google Search API 介绍 2.1 Search Analytics 2.2 站点地图 2.3 协作平台 2.4 网址检查 3 创建项目、配置服务号与验证域名所有权 3.1为什么要创建项目？ 3.2 创建项目 3.3 配置服务号 3.4 验证域名所有权 3.5 将服务账号添加为网站所有者 4 启用Google Search Console API 5 结语 Tip\n通过本文，你将了解：\n如何在Google Cloud Platform创建项目 如何验证域名所有权 如何启用Google Search API 1 前言 网络上很多有关教程都是转载来转载去，质量很差，我不想看。\n于是我便跟着Google提供的文档一步步操作，最终成功了。\n现在我将经验总结如下，希望能帮助到你。\n2 Google Search API 介绍 Info\n我该使用`Google Search Console API`还是`Google Indexing API`? Google Search Console API 和 Google Indexing API 都是关于Google Search Console的API，但是它们的功能不同。 如果你是想通过API获取网站访问信息等,那么你应该使用Google Search Console API。\n如果你是想通过API提交网站给Google Search Console，那么你应该使用Google Indexing API。\n但是本文讲解的:\n如何在Google Cloud Platform创建项目 如何验证域名所有权 这两部分，对于Google Search Console API和Google Indexing API都是通用的。因为这些API都需要在Google Cloud Platform中创建项目，并且验证域名所有权。 并且在文末我也会附上激活Google Indexing API的方法。\n请放心阅读。\nTip\nGoogle Search API 全称为 Google Search Console API ，是Google提供的一套API，可以通过API的方式获取Google Search Console的数据并进行部分操作。\n以下为Google Search API全部功能，整理自官方文档 ：\n2.1 Search Analytics 查询网站的流量数据。\n方法 HTTP 请求 说明 查询 POST /sites/siteUrl/searchAnalytics/query 使用您定义的过滤条件和参数查询搜索流量数据。该方法会返回您定义的行键（维度）分组的零行或多行。您必须定义一个或多个日期的日期范围。 JSON POST 示例:\nPOST https://www.googleapis.com/webmasters/v3/sites/https%3A%2F%2Fwww.example.com%2F/searchAnalytics/query { \u0026#34;startDate\u0026#34;: \u0026#34;2015-04-01\u0026#34;, \u0026#34;endDate\u0026#34;: \u0026#34;2015-05-01\u0026#34;, \u0026#34;dimensions\u0026#34;: [\u0026#34;country\u0026#34;,\u0026#34;device\u0026#34;] } 2.2 站点地图 方法 HTTP 请求 说明 delete DELETE /sites/siteUrl/sitemaps/feedpath 从此网站中删除站点地图。 get GET /sites/siteUrl/sitemaps/feedpath 检索关于特定站点地图的信息。 list GET /sites/siteUrl/sitemaps 列出为此网站提交的站点地图条目，或包含在站点地图索引文件中（如果请求中指定 sitemapIndex）。 提交 PUT /sites/siteUrl/sitemaps/feedpath 为网站提交站点地图。 2.3 协作平台 方法 HTTP 请求 说明 添加 PUT /sites/siteUrl 将网站添加到 Search Console 中的用户网站集。 delete DELETE /sites/siteUrl 从用户的 Search Console 网站集中移除某个网站。 get GET /sites/siteUrl 检索关于特定网站的信息。 list GET /sites 列出用户的 Search Console 网站。 2.4 网址检查 方法 HTTP 请求 说明 index.inspect POST /urlInspection/index:inspect 与 Google 索引中提供的网址相关的信息。 JSON POST 示例:\nPOST https://searchconsole.googleapis.com/v1/urlInspection/index:inspect { \u0026#34;inspectionUrl\u0026#34;: \u0026#34;https://www.example.com/mypage\u0026#34;, \u0026#34;siteUrl\u0026#34;: \u0026#34;https://www.example.com/\u0026#34;, \u0026#34;languageCode\u0026#34;: \u0026#34;en-US\u0026#34; } 3 创建项目、配置服务号与验证域名所有权 3.1为什么要创建项目？ 在Google Cloud Platform的逻辑中，你的一切操作都是在项目下进行的。\n你的域名、站点、乃至API等都属于用户的资源，这些资源会在项目中进行管理。\n简单来说，项目就是一个容器，Google在你发出请求后看容器里是否有请求的主体、请求方是否可以访问容器、请求方是否有权限对容器中的资源进行操作。满足上述条件后，Google才会对你的请求进行处理。\n因此，想要调用Google SearchAPI，你必须创建一个项目，并在验证域名所有权后，才能通过API在项目中对资源进行操作。\n3.2 创建项目 打开Google Cloud Platform ，并登录你的Google账号。 点击右上角的 Select a project ，然后点击 New Project 。创建一个新的项目。 这样，你就创建了一个新的项目。\n3.3 配置服务号 打开服务账号页面 。 点击 add 创建服务帐号，并输入服务帐号的名称和说明。您可以使用默认服务帐号 ID，也可以选择其他唯一的帐号 ID。完成后，点击创建。 后面的 服务帐号权限（可选） 部分无需设置。点击继续。 在 向用户授予访问此服务帐号的权限 屏幕上，向下滚动到创建密钥部分。点击 add 创建密钥。 在随即显示的侧面板中，选择密钥的格式。建议使用 JSON。 点击创建。你的新公钥/私钥对随后会生成并下载到您的计算机。 这样，你就创建了一个新的服务号，并下载了私钥。在完成本教程后，你可以用这个私钥访问你需要的API。 Warning\n请妥善保管你的私钥，你的私钥只能在创建时下载一次，如果丢失，你将无法再次下载。\n3.4 验证域名所有权 你可以在这里 验证域名所有权。\n3.5 将服务账号添加为网站所有者 在这里 将服务账号添加为网站所有者。\n选择添加用户。 在添加新用户对话框中，输入服务帐号的电子邮件地址。（在 3.3 步骤2中创建的服务帐号邮箱，形如my-service-account@project-name.google.com.iam.gserviceaccount.com） 将权限设置为“所有者”。 点击添加。 这样，你就将服务账号添加为网站所有者了。\n4 启用Google Search Console API 点击这里 即可启用Google Search Console API.\n此外，点击这里 即可启用Google Indexing API.\n这样，你就可以通过你的私钥调用Google Search Console API了。\n5 结语 通过本文，你应该已经了解了如何启用Google Search Console API，以及如何调用Google Search Console API。\n在一开始写这篇文章的时候，我混淆了Google Search Console API和Google Indexing API的逻辑，写到一半才意识到网站资源、token、域名所有权验证之间的逻辑关系，于是我把整篇文章重写了一遍。\n可谓教学相长了。\n"},{"section":"Blog","slug":"/blog/automatic-submit-your-page/","title":"Automatic Submit Your Page","description":"本文介绍了如何使用GitHub Actions自动推送URL至Google Search Console与百度站长平台。","date":"August 29, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech/blog/202308291727641.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"\"\n    width=\"420\" /\u003e\n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech/blog/202308291727641.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"100\"\n    width=\"100\" /\u003e\n","searchKeyword":"","categories":"技术分享, 教程","tags":"GitHub Pages, GitHub Actions, Google Search Console, 百度站长平台, SEO, 博客搭建","content":" 目录 1 前言 2 GitHub Actions 基本使用 2.1 GitHub Actions 简介 2.2 GitHub Actions 示例 3 自动推送URL至Google Search Console 4 自动推送URL至百度站长平台 5 完整的workflow 6 结语 Tip\n通过本文，你将了解：\nGitHub Actions的基本使用 如何使用GitHub Actions自动推送URL至Google Search Console 如何使用GitHub Actions自动推送URL至百度站长平台 你将得到以下方案：\n使用GitHub Actions每天定时自动推送URL至Google Search Console与百度站长平台 Note\n本方案基于使用GitHub Actions自动部署你的博客 中将站点部署到GitHub Pages的方案，并在它的基础上配置GitHub Actions实现自动推送。\n如果你没有使用过上述方案，也可以参考本文，只需自行获得站点的sitemap.xml即可。\n1 前言 新的博客总是会遇到一个问题：如何让搜索引擎知道我的博客的存在？\n这就需要我们将站点的sitemap.xml提交给搜索引擎。\n但是有的时候，仅仅提交sitemap.xml是不够的。\n最有效的方式是将你的站点所有希望被索引的URL推送给搜索引擎。\n不过，这个过程是比较繁琐的。\n本着“懒人”的原则，我研究了一套使用GitHub Actions来实现自动推送URL到Google和百度的方案。\n2 GitHub Actions 基本使用 点击查看GitHub Action介绍，熟悉的人可以跳过 2.1 GitHub Actions 简介 GitHub Actions是GitHub提供的一项功能，它可以让你在GitHub上自动化地完成一些操作。\n它的配置文件是.yml文件，放在.github/workflows目录下。\n它的结构如下：\nname: \u0026lt;workflow-name\u0026gt; # workflow的名称 on: \u0026lt;workflow-trigger\u0026gt; # workflow的触发条件 permissions: # workflow的权限 contents: read issues: write env: # workflow的环境变量 ENV: production jobs: # workflow的工作 build: runs-on: ubuntu-latest # 运行环境 steps: # workflow的步骤 - name: Checkout # 步骤名称 uses: actions/checkout@v2 # 步骤使用的action with: # 步骤的参数 ref: master fetch-depth: 0 ### 或者 ### - name: Checkout # 步骤名称 run: echo \u0026#34;Hello World\u0026#34; # 步骤的命令 具体来说：\nname: 定义工作流的名称。 on: 定义触发工作流的条件，例如 push、pull request 或定时任务。 permissions: 定义工作流的权限，例如读取内容或写入问题。 env: 定义工作流的环境变量。 jobs: 定义工作流中的任务。 runs-on: 定义任务运行的环境。 steps: 定义任务的步骤。 name: 定义步骤的名称。 uses: 定义步骤使用的 action。 with: 定义步骤的参数。 run: 定义步骤的命令。 当你的仓库中有.yml文件时，GitHub会自动检测并根据触发条件执行它。\n2.2 GitHub Actions 示例 点击查看示例 # Sample workflow for building and deploying a Hugo site to GitHub Pages name: Deploy Hugo site to Pages on: # Runs on pushes targeting the default branch push: branches: [\u0026#34;main\u0026#34;] # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages permissions: contents: read pages: write id-token: write # Environment variables available to all jobs and steps in this workflow env: HUGO_ENV: production HUGO_VERSION: \u0026#34;0.115.4\u0026#34; GO_VERSION: \u0026#34;1.20.5\u0026#34; NODE_VERSION: \u0026#34;18.15.0\u0026#34; TINA_CLIENT_ID: ${{ vars.TINA_CLIENT_ID }} TINA_TOKEN: ${{ vars.TINA_TOKEN }} jobs: # Build job build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Set up Node.js uses: actions/setup-node@v3 with: node-version: ${{ env.NODE_VERSION }} - name: Install Hugo run: | curl -LO \u0026#34;https://github.com/gohugoio/hugo/releases/download/v${{ env.HUGO_VERSION }}/hugo_extended_${{ env.HUGO_VERSION }}_Linux-64bit.tar.gz\u0026#34; tar -xvf hugo_extended_${{ env.HUGO_VERSION }}_Linux-64bit.tar.gz sudo mv hugo /usr/local/bin/ rm hugo_extended_${{ env.HUGO_VERSION }}_Linux-64bit.tar.gz hugo version - name: Install Go run: | curl -LO \u0026#34;https://dl.google.com/go/go${{ env.GO_VERSION }}.linux-amd64.tar.gz\u0026#34; sudo tar -C /usr/local -xzf go${{ env.GO_VERSION }}.linux-amd64.tar.gz echo \u0026#34;export PATH=$PATH:/usr/local/go/bin\u0026#34; \u0026gt;\u0026gt; $GITHUB_ENV rm go${{ env.GO_VERSION }}.linux-amd64.tar.gz go version - name: Setup Project run: npm run project-setup - name: Install npm dependencies run: npm install - name: Build Website run: npm run build - name: Upload artifact uses: actions/upload-pages-artifact@v1 with: path: ./public - name: Echo CNAME run: echo ${{ secrets.CNAME }} \u0026gt; ./public/CNAME - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} EXTERNAL_REPOSITORY: HaleyCH/HaleyCH.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} 这个例子是我在使用GitHub Actions自动部署你的博客 中使用的配置文件。它依次实现了：\n安装 Node.js 安装 Hugo 安装 Go 安装 npm 依赖 构建站点 上传构建好的站点到 GitHub Pages 仓库 部署 GitHub Pages 仓库 将 CNAME 文件写入 public 目录 推送 GitHub Pages 仓库 并且，每当这个仓库的代码被改变时，它都会自动执行。\n可以看到GitHub Action是一个非常强大的工具，它可以帮助我们自动化地完成一些操作。\n通过它，我们可以实现自动推送URL到Google和百度的功能。 Note\nGitHub Actions有每月配额的限制，如果你的仓库中有多个workflow，那么你可能会遇到配额不足的情况。\n不过对于个人博客来说，这个配额是足够的。\nTip\n开通GitHub Pro或者通过GitHub Education认证可以获得更多的配额。\n3 自动推送URL至Google Search Console Info\n本节的内容需要你已经拥有一个Google Search Console账号，并且已经验证了你的域名所有权。\n具体流程可以参考如何启用Google Search Console API 。\n本节假设你已经拥有了json格式的网站访问令牌。\n通过使用python的oauth2client库，我们可以实现自动推送URL至Google Search Console的功能。\n请遵循以下步骤：\n在你的仓库中，创建一个名为push_urls_to_google.py的文件，内容如下： 点击查看代码 from oauth2client.service_account import ServiceAccountCredentials import httplib2 import json import sys # https://developers.google.com/search/apis/indexing-api/v3/prereqs#header_2 JSON_KEY_FILE = \u0026#34;api-key.json\u0026#34; SCOPES = [\u0026#34;https://www.googleapis.com/auth/indexing\u0026#34;] def main(urls_file): credentials = ServiceAccountCredentials.from_json_keyfile_name(JSON_KEY_FILE, scopes=SCOPES) http = credentials.authorize(httplib2.Http()) ENDPOINT = \u0026#34;https://indexing.googleapis.com/v3/urlNotifications:publish\u0026#34; with open(urls_file, \u0026#34;r\u0026#34;) as f: urls = f.readlines() for u in urls: content = {} content[\u0026#39;url\u0026#39;] = u.strip() content[\u0026#39;type\u0026#39;] = \u0026#34;URL_UPDATED\u0026#34; json_ctn = json.dumps(content) response, content = http.request(ENDPOINT, method=\u0026#34;POST\u0026#34;, body=json_ctn) result = json.loads(content.decode()) if \u0026#34;error\u0026#34; in result: print(\u0026#34;Error({} - {}): {}\u0026#34;.format(result[\u0026#34;error\u0026#34;][\u0026#34;code\u0026#34;], result[\u0026#34;error\u0026#34;][\u0026#34;status\u0026#34;], result[\u0026#34;error\u0026#34;][\u0026#34;message\u0026#34;])) else: print(\u0026#34;urlNotificationMetadata.url: {}\u0026#34;.format(result[\u0026#34;urlNotificationMetadata\u0026#34;][\u0026#34;url\u0026#34;])) print(\u0026#34;urlNotificationMetadata.latestUpdate.url: {}\u0026#34;.format(result[\u0026#34;urlNotificationMetadata\u0026#34;][\u0026#34;latestUpdate\u0026#34;][\u0026#34;url\u0026#34;])) print(\u0026#34;urlNotificationMetadata.latestUpdate.type: {}\u0026#34;.format(result[\u0026#34;urlNotificationMetadata\u0026#34;][\u0026#34;latestUpdate\u0026#34;][\u0026#34;type\u0026#34;])) print(\u0026#34;urlNotificationMetadata.latestUpdate.notifyTime: {}\u0026#34;.format(result[\u0026#34;urlNotificationMetadata\u0026#34;][\u0026#34;latestUpdate\u0026#34;][\u0026#34;notifyTime\u0026#34;])) if __name__ == \u0026#34;__main__\u0026#34;: if len(sys.argv) \u0026lt; 2: print(\u0026#34;Usage: python push_urls_to_google.py \u0026lt;urls_file\u0026gt;\u0026#34;) else: urls_file = sys.argv[1] main(urls_file) 并将`json`格式的`Google SearchAPI`凭据命名为`api-key.json`，放在仓库的根目录下。 当然，安全起见，你也可以将它放在`GitHub Secrets`中，然后在`push_urls_to_google.py`中读取它。但是我的workflow并没有实现这个功能，读者可以自行实现。 这段代码将读取同目录下`api-key.json`并从输入中读取待推送的URL列表，并将它们推送至Google Search Console。 Warning\n请务必将仓库设为private，否则你的Google SearchAPI凭据将会被公开。\n在你的仓库.github/workflows目录下，创建一个名为push_urls_to_google.yml的文件，设定如下所示的触发条件: name: Push Latest URLs Once a Day on: schedule: - cron: \u0026#34;0 0 * * *\u0026#34; workflow_dispatch: # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages permissions: contents: read pages: write id-token: write 这表示这个Action将在UTC时间的每天0点自动执行。\n获得sitemap.xml的URL。 如果你是根据使用GitHub Actions自动部署你的博客 中的方案部署的博客，那么你可以在push_urls_to_google.yml中添加以下代码： 点击查看代码 jobs: # Build job build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Set up Node.js uses: actions/setup-node@v3 with: node-version: ${{ env.NODE_VERSION }} - name: Install Hugo run: | curl -LO \u0026#34;https://github.com/gohugoio/hugo/releases/download/v${{ env.HUGO_VERSION }}/hugo_extended_${{ env.HUGO_VERSION }}_Linux-64bit.tar.gz\u0026#34; tar -xvf hugo_extended_${{ env.HUGO_VERSION }}_Linux-64bit.tar.gz sudo mv hugo /usr/local/bin/ rm hugo_extended_${{ env.HUGO_VERSION }}_Linux-64bit.tar.gz hugo version - name: Install Go run: | curl -LO \u0026#34;https://dl.google.com/go/go${{ env.GO_VERSION }}.linux-amd64.tar.gz\u0026#34; sudo tar -C /usr/local -xzf go${{ env.GO_VERSION }}.linux-amd64.tar.gz echo \u0026#34;export PATH=$PATH:/usr/local/go/bin\u0026#34; \u0026gt;\u0026gt; $GITHUB_ENV rm go${{ env.GO_VERSION }}.linux-amd64.tar.gz go version - name: Setup Project run: npm run project-setup - name: Install npm dependencies run: npm install - name: Build Website run: npm run build - name: Upload artifact uses: actions/upload-pages-artifact@v1 with: path: ./public - name: Echo CNAME run: echo ${{ secrets.CNAME }} \u0026gt; ./public/CNAME - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} EXTERNAL_REPOSITORY: HaleyCH/HaleyCH.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} 它将自动部署你的网页，这样你就可以获得`sitemap.xml`了。 对于其他方案，你需要自行获得sitemap.xml并将其读入workflow中。\n在push_urls_to_google.yml中添加以下代码： - name: Extract Latest URLs run: | latest_urls=$(grep -o \u0026#39;\u0026lt;loc\u0026gt;[^\u0026lt;]*\u0026lt;/loc\u0026gt;\u0026#39; ./public/sitemap.xml | sed \u0026#39;s/\u0026lt;loc\u0026gt;\\(.*\\)\u0026lt;\\/loc\u0026gt;/\\1/\u0026#39; | head -n 100) echo \u0026#34;$latest_urls\u0026#34; \u0026gt; latest_urls.txt 他将读取./public/sitemap.xml中的前100条URL，并将它们写入latest_urls.txt中。\n配置环境并运行脚本： - name: install python uses: actions/setup-python@v2 with: python-version: \u0026#39;3.x\u0026#39; - name: Install dependencies run: | python -m pip install --upgrade pip pip install oauth2client pip install httplib2 - name: Push Latest URLs to Google run: | pwd ls -l python ./push_urls_to_google.py latest_urls.txt 这段代码会自动配置python环境与依赖项，并且运行push_urls_to_google.py脚本。\n4 自动推送URL至百度站长平台 Info\n本节的内容需要你已经拥有一个百度站长平台账号，并且已经验证了你的域名所有权。\n由于这一步较为简单，我不会详细讲解。\n在workflow中添加以下代码即可:\n- name: Push Latest URLs to Baidu run: | while IFS= read -r url; do curl -H \u0026#34;Content-Type:text/plain\u0026#34; --data-binary \u0026#34;$url\u0026#34; \u0026#34;http://data.zz.baidu.com/urls?site=\u0026lt;yourDomain\u0026gt;\u0026amp;token=\u0026lt;yourToken\u0026gt;\u0026#34; done \u0026lt; latest_urls.txt 它会自动读取latest_urls.txt中的URL，并将它们推送至百度站长平台。\n5 完整的workflow 点击查看完整的workflow name: Push Latest URLs Once a Day on: schedule: - cron: \u0026#34;0 0 * * *\u0026#34; workflow_dispatch: # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages permissions: contents: read pages: write id-token: write # Environment variables available to all jobs and steps in this workflow env: HUGO_ENV: production HUGO_VERSION: \u0026#34;0.115.4\u0026#34; GO_VERSION: \u0026#34;1.20.5\u0026#34; NODE_VERSION: \u0026#34;18.15.0\u0026#34; TINA_CLIENT_ID: ${{ vars.TINA_CLIENT_ID }} TINA_TOKEN: ${{ vars.TINA_TOKEN }} jobs: # Build job build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Set up Node.js uses: actions/setup-node@v3 with: node-version: ${{ env.NODE_VERSION }} - name: Install Hugo run: | curl -LO \u0026#34;https://github.com/gohugoio/hugo/releases/download/v${{ env.HUGO_VERSION }}/hugo_extended_${{ env.HUGO_VERSION }}_Linux-64bit.tar.gz\u0026#34; tar -xvf hugo_extended_${{ env.HUGO_VERSION }}_Linux-64bit.tar.gz sudo mv hugo /usr/local/bin/ rm hugo_extended_${{ env.HUGO_VERSION }}_Linux-64bit.tar.gz hugo version - name: Install Go run: | curl -LO \u0026#34;https://dl.google.com/go/go${{ env.GO_VERSION }}.linux-amd64.tar.gz\u0026#34; sudo tar -C /usr/local -xzf go${{ env.GO_VERSION }}.linux-amd64.tar.gz echo \u0026#34;export PATH=$PATH:/usr/local/go/bin\u0026#34; \u0026gt;\u0026gt; $GITHUB_ENV rm go${{ env.GO_VERSION }}.linux-amd64.tar.gz go version - name: Setup Project run: npm run project-setup - name: Install npm dependencies run: npm install - name: Build Website run: npm run build - name: Upload artifact uses: actions/upload-pages-artifact@v1 with: path: ./public - name: Echo CNAME run: echo ${{ secrets.CNAME }} \u0026gt; ./public/CNAME - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} EXTERNAL_REPOSITORY: HaleyCH/HaleyCH.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} - name: Extract Latest URLs run: | latest_urls=$(grep -o \u0026#39;\u0026lt;loc\u0026gt;[^\u0026lt;]*\u0026lt;/loc\u0026gt;\u0026#39; ./public/sitemap.xml | sed \u0026#39;s/\u0026lt;loc\u0026gt;\\(.*\\)\u0026lt;\\/loc\u0026gt;/\\1/\u0026#39; | head -n 100) echo \u0026#34;$latest_urls\u0026#34; \u0026gt; latest_urls.txt - name: Push Latest URLs to Baidu run: | while IFS= read -r url; do curl -H \u0026#34;Content-Type:text/plain\u0026#34; --data-binary \u0026#34;$url\u0026#34; \u0026#34;http://data.zz.baidu.com/urls?site=hluvmiku.tech\u0026amp;token=x1rQVPzQUzr3sm35\u0026#34; done \u0026lt; latest_urls.txt - name: install python uses: actions/setup-python@v2 with: python-version: \u0026#39;3.x\u0026#39; - name: Install dependencies run: | python -m pip install --upgrade pip pip install oauth2client pip install httplib2 - name: Push Latest URLs to Google run: | pwd ls -l python ./push_urls_to_google.py latest_urls.txt 6 结语 使用GitHub Actions可以将许多琐碎的、重复的工作自动化，让我们可以专注于更有意义的事情。\n本文我提出了一套自动化推送方案，但是它仍然存在推送不够智能的问题。\n大家有兴趣可以自行研究。\n"},{"section":"Blog","slug":"/blog/nintendo-switch-simulator/","title":"Nintendo Switch Joycon Simulator","description":"使用ESP-32、STM32或CH32开发板设置模拟jycon手柄的详细教程。","date":"August 28, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech/blog/202308281657027.JPG\"\n    alt=\"\"\n    class=\" img\"\n    height=\"\"\n    width=\"420\" /\u003e\n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech/blog/202308281657027.JPG\"\n    alt=\"\"\n    class=\" img\"\n    height=\"100\"\n    width=\"100\" /\u003e\n","searchKeyword":"","categories":"游戏, DIY, 教程","tags":"Nintendo Switch, Simulator, ESP-32, STM32, CH32","content":" 目录 1 前言 2 准备工作 2.1 下载整合包 2.2 购买对应的开发板 2.2.1 ESP-32 2.2.2 其他 2.3 安装驱动 2.4 烧录固件 3 使用EasyCon 3.1 下载EasyCon并使用 3.2 EasyCon语法介绍 按键 摇杆 等待 注释 输出 消息推送 循环 常量与变量 赋值 含变量的基础语句 条件分支 4 部分脚本 5 进阶操作 6 结语 Note\n本教程需要你拥有一张ESP-32、STM32或者CH32开发板。并且本文只基于ESP-32进行讲解。\n1 前言 本文只是一个粗浅的教程，详细可以加QQ群946057081讨论。\n在开始正文前，我想先列举一下我尝试过的方案。\nNXBT :这是目前最火的项目，但是它要求使用树莓派或者linux系统的PC。\n树莓派太贵，所以我没采用。\n之后我又折腾过 WSL、VMWare、VirtualBox，但是都没成功。\nVMWare是我最接近成功的一次，有兴趣各位可以试试。\n而且此项目年久失修，我估计switch到16.0固件以后就没法用了。 NintendoSwitchController : 纯日语项目，很不友好，需要Arduino Leonardo，贵。 EasyCon ：本文主角。支持多种单片机，价格控制在50元人民币以内，可以自制脚本，接上采集卡还能使用图像识别（采集卡要另外买，差不多200来块），功能强大。 2 准备工作 2.1 下载整合包 首先，你需要下载整合包。\n这里我提供了交流群中2022年12月更新的文件：\nESP-32 STM32 CH32 点击下载ESP32整合包 点击下载STM32整合包 点击下载CH32整合包 你可以根据自己的需求选择下载不同的文件。\n2.2 购买对应的开发板 建议根据下载的整合包里的PDF文件购买开发板。\n2.2.1 ESP-32 我使用的是ESP-32。\nNote\n请注意不要购买ESP32-Cx、 ESP32-Sx型号。\n并且最好购买带有`cp2102关键字的开发版。\n薄膜键盘可以不用买，但是数据线一定要买，是比较老的那种接口，具体可以问客服。\n针脚可以联系客服让厂商帮你焊好（不焊也可以用）。\n这里是我的购买截图 2.2.2 其他 请参考整合包中PDF文件进行购买。\n2.3 安装驱动 如果整合包中包含驱动，则安装驱动，\n若无，直接进行下一步。\n2.4 烧录固件 所有的整合包中都包含EasyCon固件以及烧录文件，你可以直接烧录。\n下面我将以ESP-32为例进行讲解。\n1、 启动烧录程序。点击烧录程序后，选择ESP32，然后点击OK。\n你应该会看到如图所示界面 2、 点击...，选择整合包中的固件，并选中。在后方的地址输入 0x0。并选择正确的串口。\n3、 点击start\n出现如图所示的界面代表烧录成功 3 使用EasyCon 3.1 下载EasyCon并使用 你可以在这里 找到对应文件。\n下载并解压他们。\n打开后你会看到这样的界面。\n点击自动连接即可与开发版连接。\n3.2 EasyCon语法介绍 按键 语法：键位 [持续时间(ms)|DOWN|UP] 示例：A（按下A键50毫秒）、HOME 1000（按下Home键1秒）、LEFT DOWN（按住左十字键，需要手动用LEFT UP松开） 全部按键：A、B、X、Y、UP、DOWN、LEFT、RIGHT、MINUS、PLUS、L、R、ZL、ZR、HOME、CAPTURE。 摇杆 语法： LS|RS 方向|角度 [, 持续时间(ms)] LS|RS RESET LSS|RSS 方向 (1.45新增慢推语法，仅支持方向，不支持角度) 等待 语法：[WAIT] 等待时间(ms) 示例：WAIT 500、2000 注释 语法：# 注释内容 注意：多写注释是个好习惯，尤其是分享脚本给别人的时候。 输出 语法：PRINT 输出内容 注意：联机模式专用，在控制台显示文字。 消息推送 语法：ALERT 输出内容 注意：联机模式专用，发送推送消息，基于推送加服务。需要先关注\u0026lt;pushplus推送加\u0026gt;小程序生成token并在设置-\u0026gt;推送设置页面配置。 循环 语法： FOR [循环次数]\n\u0026hellip;\nNEXT 常量与变量 常量语法：常量名 = 值 变量基础语法：$索引 变量进阶语法：$变量名、$$变量名 赋值 语法：目标变量 = 值 或 目标变量 = 来源变量 含变量的基础语句 输出：PRINT 用\u0026amp;分隔的输出内容 按键：键位 变量名 摇杆：LS|RS 方向|角度 变量名 等待：WAIT 变量名 条件分支 语法： IF 条件\n\u0026hellip;\nELSE \u0026hellip; ENDIF 4 部分脚本 自动刷活动 Note\n需要不在同行第一只宝可梦放刷活动用宝可梦，并且该宝可梦第一个技能应该为需要使用的技能。\n使用时，需连接网络，并进入联机太晶对战界面再运行脚本。\n此外，还需要将捕捉用的精灵球选择为普通球（否则太浪费）并且买999个。\nFOR X 100 WAIT 100 A 100 WAIT 100 NEXT 自动取孵 #1.语速调到最快，关闭取名，关闭学技能，自动记录最好关闭 #2.将【园模镇：西】标记为目的地，并打开原地旋转模式 #3.同行携带要生蛋的两只宝可梦 #4.将盒子打开的界面调成将要放蛋的第一个空箱子 #5.放蛋的空箱子的前一个箱子第一列空出来，第二列只放火焰之躯宝可梦【孵蛋用】 #6.菜单界面光标默认调到野餐，脚本开始时人物退出盒子，退出菜单，并骑上神兽 #7.初始站位需站在园模镇橄榄球场远离可梦中心球筐左侧，面朝宝可梦中心，球筐在右侧 #8.默认20周期的，孵其他宝可梦，孵蛋时间需自行调节，料理位置按自己的配方调整 #9.部分延时为防止卡顿，加的时间有点长，可自行修改，如果野餐不成功，请重新开始即可 #10.by 倚夏\u0026amp;law 宝可梦取孵一体脚本2.86【圆模镇】(往复式孵蛋) #【※※※※运行前清修改数值※※※※】 #======初始数值调整【必看】====== _孵蛋箱数 = 1 #需自行计算箱数，一次料理54+颗蛋左右【一次料理，孵蛋两箱，约1.5小时】 _孵蛋周期 = 25 #直接填写孵蛋宝可梦的孵蛋周期，可看下方的周期表 _料理次数 = 4 #一次料理54颗蛋左右，根据料理次数换算成你要孵蛋的箱数 _料理位置 = 8 #就是17号配方【超级花生酱三文治】在第几行 _料理左右 = 0 #就是17号配方【超级花生酱三文治】在 0左 还是 1右 _跳过野餐 = 1 #1开启，不进行野餐直接孵蛋，初始站位不变，并将光标放到孵蛋的第一箱第一个蛋，同行只有一只孵蛋用宝可梦 _蛋蛋力LV3 = 1 #1开启，将制作蛋蛋力LV3，需要两个甜味料和一份生菜，一次料理85颗左右 _甜味料位置 = 5 #倒数第几行 #======进阶调整数值【可选】====== _孵蛋延时 = 60 #默认60，如果存在没孵出来的蛋，打开图鉴或者服装，自行加大，每加1延迟孵蛋时间2秒 _拿取延时 = 100 #默认100，改小增大吞键可能性 _按键延迟 = 500 #默认500，按键间隔的延迟 _复位功能 = 1 #1开启 0关闭 _复位周期 = 3 #几箱复位一次 _往对侧 = 3500 #往球场对侧方向行走时间 _往中心 = 1500 #往球场中心方向行走时间 _闪光识别 = 0 #1开启，需用采集卡，并自制标签，烧录需注释【@闪光】 _自动放生闪光识别 = 0 #1开启，需用采集卡，烧录需删除放生代码 #自行按照以下周期选择适合的（周期数据查询神奇百科） #网站：https://wiki.52poke.com/wiki/宝可梦列表（按孵化周期分类） #孵蛋时间有盈余的，会在第一个蛋的界面空转几圈 #5周期= 5 例如鲤鱼王 #10周期=10 例如一对鼠 #15周期=15 例如斗笠菇 #20周期=20 例如小火龙 #25周期=25 例如冰砌鹅 #30周期=30 例如沙河马 #35周期=35 例如伊布 #40周期=40 例如烈咬陆鲨 #函数-------------------------- FUNC POINT #朝向目的地 600 Y 200 2700 B 200 2000 L 100 400 ENDFUNC #函数-------------------------- # 准备阶段 FOR 5 RCLICK 200 NEXT #开始运行 $5 = _跳过野餐 IF $5 = 0 #自动野餐---------------------------------------------------- PRINT 自动野餐开始 CALL POINT LS 270,500 500 LS 270 B 200 WAIT 1500 LS RESET 300 LS 90,2000 200 PLUS 200 300 LS 270,700 CALL POINT PRINT 走到野餐位置，开始野餐 FOR 3 X 50 50 NEXT FOR 5 50 A 100 50 NEXT WAIT 7000 #等待野餐时间 L 500 WAIT 1000 #走到篮子位置 LS UP,200 WAIT _按键延迟 LS LEFT,320 WAIT _按键延迟 LS UP,500 WAIT _按键延迟 LS RIGHT,330 WAIT _按键延迟 LS DOWN,300 WAIT 500 #做料理 $1 = 1 FOR _料理次数 500 PRINT 开始做料理 LS DOWN,200 WAIT _按键延迟 FOR 10 50 A 100 50 NEXT WAIT 5000 #等待选配方界面 $5 = _蛋蛋力LV3 IF $5 = 0 #17号料理 根据料理位置设置次数 PRINT 制作17号料理 $4 = _料理位置 $4 -= 1 FOR $4 LS DOWN,100 100 NEXT $4 = _料理左右 #判定料理配方在左右 IF $4 = 0 #在左 WAIT 100 ELSE #在右 LS RIGHT,100 WAIT 200 ENDIF WAIT _按键延迟 FOR 5 50 A 100 50 NEXT WAIT 8000 #开始做三文治 FOR 3 LS 90,550 100 A DOWN 100 LS 270,525 A UP 100 NEXT #放面包和签子 WAIT 3000 LS UP,550 WAIT _按键延迟 FOR 120 #等三文治转圈画面 50 A 100 50 NEXT $5 = 7 #蛋蛋力LV2拿蛋7轮 $4 = 23 ELSE PRINT 制作蛋蛋力LV3料理 $4 = _甜味料位置 X 200 200 A 200 200 PLUS 200 200 FOR $4 100 UP 100 100 NEXT 200 FOR 2 100 A 100 100 NEXT 200 PLUS 200 200 A 200 WAIT 8000 #等待做料理 LS UP,550 FOR 130 #等三文治转圈画面 50 A 100 50 NEXT $5 = 10 #蛋蛋力LV3拿蛋10轮 $4 = 16 ENDIF 8000 #吃料理时间 A 200 2000 PRINT 吃料理时间 PRINT 吃了 \u0026amp; $1 \u0026amp; 次料理 $1 += 1 LS UP,45 WAIT _按键延迟 # 拿蛋阶段 PRINT 开始拿蛋 $3 = 1 FOR $5 #等待过程中每10秒吹一次口哨 FOR $4 R 200 WAIT 10000 NEXT #连A拿蛋 FOR 52 A 100 WAIT 300 NEXT #连B取消对话框 300 B 100 WAIT 300 B 100 WAIT 300 #循环一次时间5分 PRINT 拿蛋 \u0026amp; $3 \u0026amp; 轮 $3 += 1 NEXT # 返回循环做料理 NEXT PRINT 野餐拿蛋结束 # 结束野餐 2000 FOR 5 50 Y 100 50 NEXT FOR 13 150 A 200 150 NEXT 200 PRINT 开始返回球场 LS 270,200 500 PLUS 600 #返回球场 500 LS 90,1200 #走到栏杆边 200 LS 90 B 300 1000 LS RESET CALL POINT LS 270,1000 #交换工具人---------------------------------------------------- PRINT 交换工具人 500 #拿出孵蛋宝可梦 FOR 3 X 50 50 NEXT 3000 UP 200 FOR 5 50 A 100 50 NEXT 2000 L 200 500 RIGHT _拿取延时 200 Y 200 300 FOR 2 100 LEFT _拿取延时 100 NEXT 300 FOR 2 100 DOWN _拿取延时 100 NEXT 200 A 100 200 UP _拿取延时 300 MINUS 300 FOR 5 UP 50 NEXT 100 A 100 200 RIGHT _拿取延时 200 A 100 200 R 200 500 PRINT 交换已完成 ENDIF #自动孵蛋----------------------------------------------------- $1 = 1 #列数 1为第一列，不要修改 $2 = 1 #已孵蛋箱数 $3 = _孵蛋周期 $3 *= 3 $3 /= 2 $3 += _孵蛋延时 $6 = 1 PRINT 开始孵蛋 FOR _孵蛋箱数 FOR 6 #盒子取蛋 500 MINUS 300 FOR 8 DOWN 50 NEXT 100 A 100 200 DOWN _拿取延时 100 FOR $1 100 LEFT _拿取延时 100 NEXT FOR 3 A 100 100 NEXT FOR 13 50 B 100 50 NEXT 1500 #往复式孵蛋---------------------------- LS 90,_往对侧 FOR $3 FOR 10 LS 90 A 50 NEXT FOR 10 LS 270 A 50 NEXT NEXT LS RESET LS 270,4500 #往复式孵蛋---------------------------- 500 #复位 $5 = _复位功能 IF $5 = 1 IF $6 = _复位周期 IF $1 = 6 $6 = 0 LS 180,100 400 L 100 600 LS 90,2000 500 LS 270,_往中心 600 CALL POINT ENDIF ENDIF ENDIF 500 #宝可梦放回盒子 FOR 3 X 50 50 NEXT FOR 5 50 A 100 50 NEXT 2000 DOWN _拿取延时 300 LEFT _拿取延时 300 #自动放生代码【烧录需删除】-------------------------- $5 = _自动放生闪光识别 $4 = 0 IF $5 = 1 PRINT 开始放生 FOR 5 $5 = @LV IF $5 \u0026lt; 95 BREAK ENDIF $5 = @闪光 IF $5 \u0026gt; 95 PRINT 第 \u0026amp; $2 \u0026amp; 箱第 \u0026amp; $1 \u0026amp; 列出闪了!!! DOWN 100 300 $4 += 1 ELSE FOR $5 = @打开菜单 IF $5 \u0026gt; 95 BREAK ELSE A 100 500 ENDIF NEXT FOR $5 = @放生 IF $5 \u0026gt; 95 BREAK ELSE UP 100 200 ENDIF NEXT FOR $5 = @放生2 IF $5 \u0026gt; 95 BREAK ELSE A 100 1200 ENDIF NEXT FOR $5 = @放生3 IF $5 \u0026gt; 95 BREAK ELSE UP 100 400 ENDIF NEXT FOR $5 = @放生4 IF $5 \u0026gt; 95 A 100 1500 ELSE BREAK ENDIF NEXT ENDIF NEXT IF $4 \u0026gt; 0 FOR $5 = @回到第二行 IF $5 \u0026lt; 95 UP 100 200 ELSE BREAK ENDIF NEXT ENDIF ENDIF #自动放生代码--------------------------\tMINUS 300 #闪光识别代码----------------------------------------------------- FOR 8 $5 = _闪光识别 IF $5 = 1 #烧录模式将下行的代码注释掉，在前面加上【#】即可，无采集卡同理 $5 = @闪光 #烧录需将此行注释，如【#$5 = 闪光】 IF $5 \u0026gt; 95 PRINT 第 \u0026amp; $2 \u0026amp; 箱第 \u0026amp; $1 \u0026amp; 列出闪了!!! ENDIF ENDIF DOWN 100 100 NEXT #闪光识别代码----------------------------------------------------- 300 A 100 FOR 3 UP 100 NEXT 300 FOR $1 100 RIGHT _拿取延时 100 NEXT FOR 3 A 100 100 NEXT FOR 3 B 100 100 NEXT 2000 FOR 3 A 50 NEXT 2000 IF $1 != 6 #换下一列 FOR $1 100 RIGHT _拿取延时 100 NEXT ELSE 200 R 100 300 ENDIF PRINT 第 \u0026amp; $2 \u0026amp; 箱第 \u0026amp; $1 \u0026amp; 列已孵完 $1 += 1 NEXT $2 += 1 $6 += 1 $1 = 1 NEXT PRINT 结束 5 进阶操作 你可以购买一个采集卡，然后自制标签，这样就可以使用图像识别了。\n6 结语 使用EasyCon和相关的开发板为Nintendo Switch玩家提供了一种便捷、经济的方式来自定义并模拟控制器的操作。无论你是希望为特定游戏创建自定义的宏，还是希望进行更复杂的操作，本教程为你提供了开始的基础。\n"},{"section":"Blog","slug":"/blog/build-your-blog-2/","title":"Build Your Blog 2","description":"关于使用Git备份您的站点、使用GitHub Actions自动部署Hugo站点以及为GitHub Pages博客设置自定义域名的逐步指南。","date":"August 28, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech/blog/202308281503218.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"\"\n    width=\"420\" /\u003e\n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech/blog/202308281503218.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"100\"\n    width=\"100\" /\u003e\n","searchKeyword":"","categories":"技术分享, 博客搭建, 教程","tags":"Hugo, GitHub Pages, GitHub Actions, Custom Domain, Blogging, 博客搭建","content":" 目录 1 前言 2 使用Git与GitHub备份全站 2.1 初始化Git 2.2 配置.gitignore 3 使用GitHub Actions自动部署全站 3.1 创建GitHub Actions 3.2 配置GitHub Secrets 3.3 部署博客 4 （可选）使用自定义域名 5 结语 Note\n本文章是 使用hugo+GitHub Pages搭建免费博客 的续篇。\n下文假设你已经：\n拥有自己的GitHub Pages仓库 安装了hugo并完成有关配置 1 前言 通过这篇文章，你将获得以下方案：\n使用Git与GitHub备份全站 使用GitHub Actions自动部署全站 使用自定义域名 2 使用Git与GitHub备份全站 2.1 初始化Git 在GitHub上创建一个新的private仓库，仓库名为 blogName 。 Warning\n请务必设置为private仓库，否则你的配置文件中的私密信息将会被公开。\n在你的站点目录下执行以下命令：\ngit init git remote add origin \u0026lt;your-repo-url\u0026gt; git add . git commit -m \u0026#34;init\u0026#34; git push -u origin master 2.2 配置.gitignore 在你的站点目录下创建 .gitignore 文件，内容如下：\n/public 这可以防止你的 public 目录被提交到仓库中。\n3 使用GitHub Actions自动部署全站 3.1 创建GitHub Actions 在你的站点目录下创建 .github/workflows/gh-pages.yml 文件，内容如下：\n点击查看配置文件 # Sample workflow for building and deploying a Hugo site to GitHub Pages name: Deploy Hugo site to Pages on: # Runs on pushes targeting the default branch push: branches: [\u0026#34;main\u0026#34;] # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages permissions: contents: read pages: write id-token: write # Environment variables available to all jobs and steps in this workflow env: HUGO_ENV: production HUGO_VERSION: \u0026#34;0.115.4\u0026#34; GO_VERSION: \u0026#34;1.20.5\u0026#34; NODE_VERSION: \u0026#34;18.15.0\u0026#34; TINA_CLIENT_ID: ${{ vars.TINA_CLIENT_ID }} TINA_TOKEN: ${{ vars.TINA_TOKEN }} jobs: # Build job build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Set up Node.js uses: actions/setup-node@v3 with: node-version: ${{ env.NODE_VERSION }} - name: Install Hugo run: | curl -LO \u0026#34;https://github.com/gohugoio/hugo/releases/download/v${{ env.HUGO_VERSION }}/hugo_extended_${{ env.HUGO_VERSION }}_Linux-64bit.tar.gz\u0026#34; tar -xvf hugo_extended_${{ env.HUGO_VERSION }}_Linux-64bit.tar.gz sudo mv hugo /usr/local/bin/ rm hugo_extended_${{ env.HUGO_VERSION }}_Linux-64bit.tar.gz hugo version - name: Install Go run: | curl -LO \u0026#34;https://dl.google.com/go/go${{ env.GO_VERSION }}.linux-amd64.tar.gz\u0026#34; sudo tar -C /usr/local -xzf go${{ env.GO_VERSION }}.linux-amd64.tar.gz echo \u0026#34;export PATH=$PATH:/usr/local/go/bin\u0026#34; \u0026gt;\u0026gt; $GITHUB_ENV rm go${{ env.GO_VERSION }}.linux-amd64.tar.gz go version - name: Setup Project run: npm run project-setup - name: Install npm dependencies run: npm install - name: Build Website run: npm run build - name: Upload artifact uses: actions/upload-pages-artifact@v1 with: path: ./public - name: Echo CNAME run: echo ${{ secrets.CNAME }} \u0026gt; ./public/CNAME - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} EXTERNAL_REPOSITORY: ${{ secrets.PAGE_URL }} PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} 仔细观察代码，你会发现有一些变量需要你自己填写。\n3.2 配置GitHub Secrets 在你的仓库中，点击 Settings -\u0026gt; Secrets -\u0026gt; New repository secret ，添加以下变量：\nPERSONAL_TOKEN\n这是你的GitHub Personal Token，用于推送到仓库中。\n点击这里 获得你的Token。 PAGE_URL\n这是你的GitHub Pages仓库的URL，格式应该为 username.github.io 。 CNAME(可选)\n这是你的自定义域名，格式应该为 example.com 。 点击查看示例 3.3 部署博客 观察GitHub Actions的配置文件，你会发现，只有在main分支提交时，才会触发自动部署。\n# Sample workflow for building and deploying a Hugo site to GitHub Pages name: Deploy Hugo site to Pages on: # Runs on pushes targeting the default branch push: branches: [\u0026#34;main\u0026#34;] 因此，我们需要将静态文件推送到main分支中就能完成部署。\ngit add . git commit -m \u0026#34;init\u0026#34; git push origin main 或者在GitHub网页中编辑完文章后，点击Commit changes按钮。\n这样，你应该就能在username.github.io中看到你的博客了。\n4 （可选）使用自定义域名 如果你想要绑定域名，可以在 GitHub Pages 的设置中，将 Custom domain 设置为你的域名。\n此外，你还需要在你的域名服务商中，添加一条 CNAME 记录，将 yourCustom.domain 指向你的博客域名username.github.io。 Tip\n有时，你或许需要在你的域名服务商中，添加一条 A 记录，将 yourCustom.domain 指向 GitHub对应的IP地址。\n这样你就可以通过yourCustom.domain访问你的博客了。\n5 结语 至此，你的博客就已经可以自动部署了。\n下一篇文章中，我将分享我将博客文章图片托管至OSS的方案。\n"},{"section":"Blog","slug":"/blog/build-your-blog-1/","title":"Build Your Blog 1","description":"本文介绍了如何使用hugo、如何配置hugo，并讲解了如何使用GitHub Pages搭建免费博客。","date":"August 28, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech/blog/202308281329993.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"\"\n    width=\"420\" /\u003e\n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech/blog/202308281329993.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"100\"\n    width=\"100\" /\u003e\n","searchKeyword":"","categories":"技术分享, 博客搭建, 教程","tags":"hugo, GitHub Pages, 博客搭建, Go","content":" 目录 1 前言 2 安装hugo 3 配置hugo与挑选主题 4 使用GitHub Pages部署免费博客 4.1 创建GitHub Pages 4.2 部署博客 4.3 （可选）绑定域名 5 结语 1 前言 Note\n注意：我并不推荐这套方案，比起这套方案，hexo + GitHub Pages有着更加完善的生态。\n如果说是使用托管服务搭建博客的话，其实我并不是很建议 hugo 。\nhugo 相较于 hexo 来说，配置起来比较麻烦，而且 hugo 的主题插件也比较少。\n它的优势在哪呢？它的唯一优势是生成速度快。但是既然都使用托管服务了，那么生成速度就不在我们的考量中。\n那么为什么我还是使用 hugo 呢？\n单纯是因为我一开始是想部署到自己服务器上的，后来才发现部署到 GitHub Pages 上更方便。\n2 安装hugo 首先安装 Go。\nmacOS Linux Windows brew install go sudo apt install golang-go 下载地址 安装完成后，执行 go version 查看是否安装成功。\n接下来去GitHub的release页面下载 hugo 的二进制文件。\n下载地址 或者，如果你使用的是 MacOS ，可以直接使用 brew 安装。\nbrew install hugo 根据 README.md 安装即可。\n安装完成后，使用 hugo new site blogName 创建一个新的站点。\n3 配置hugo与挑选主题 Note\n每个主题的配置文件都略微有区别，本文只挑选共性的部分进行讲解。\n我使用的是 hugoplate 主题，其他主题也大同小异。\n你可以在这里 挑选你喜欢的主题。\n并按照它的文档进行安装。\n安装完主题后，我们需要配置 config.toml 文件。\n（在 hugoplate 主题中，配置文件是 hugo.toml ，其他主题可能是 config.toml ）\n首先我们按照需求填写基本信息。 baseURL 部分可以等创建完GitHub Pages后再进行填写。\nbaseURL = \u0026#34;https://hluvmiku.tech\u0026#34; # Title of your website (required). title = \u0026#34;HaleyCH\u0026#39;s Blog\u0026#34; # Your theme name theme = \u0026#34;hugoplate\u0026#34; # Default time zone for time stamps; use any valid tz database name: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List timeZone = \u0026#34;Asia/Shanghai\u0026#34; 其中theme修改为你使用的主题名称。\nNote\n请务必配置 baseURL ，否则你的网站将无法正常访问。\n下方内容按需配置：\n配置语言与多国语 Tip\n不建议使用多国语言，虽然hugo原生支持多国语言，但是多国语生成的sitemap会不被某些搜索引擎接受。\n在 hugoplate 主题中，语言与目录配置文件在 config/_default 目录下。\n若要支持多国语，只需修改 languages.toml 文件即可。\n################ English language ################## [en] languageName = \u0026#34;english\u0026#34; languageCode = \u0026#34;en\u0026#34; contentDir = \u0026#34;content/en\u0026#34; weight = 1 ################ Chinese language ################## # [zh] # languageName = \u0026#34;中文\u0026#34; # languageCode = \u0026#34;zh\u0026#34; # contentDir = \u0026#34;content/en\u0026#34; # weight = 1 其中languageCode为语言代码，contentDir为语言对应的内容目录。\n他们分别同目录下的menus.en.toml和 content 目录下的 en 目录对应。\n若要修改目录对应的翻译，则需修改对应语言的 menus.toml 文件。\n如果有i18n目录，则需修改 i18n 目录下对应语言的 toml 文件。\n定制你的博客 Note\n这一块不同主题差距比较大，我只我对 hugoplate 主题的配置为例。\n我先对config/_default目录下params.torml文件进行配置。\nfavicon = \u0026#34;images/favicon.png\u0026#34; # 网站图标 logo = \u0026#34;\u0026#34; # logo 由于我没有，故为空。 logo_darkmode = \u0026#34;\u0026#34; # theme-mode theme_switcher = true theme_default = \u0026#34;system\u0026#34; # available options [light/dark/system] copyright = \u0026#34;Made with ❤️ by Haley.\u0026lt;br\u0026gt;Since 2023\u0026#34; # copyright 以上是基础的网站信息配置，下面是一些SEO配置。\n# seo meta data for OpenGraph / Twitter Card [metadata] keywords = [\u0026#34;technology\u0026#34;, \u0026#34;blog\u0026#34;] description = \u0026#34;Hugo \u0026amp; Tailwindcss Starter\u0026#34; author = \u0026#34;HaleyCH\u0026#34; image = \u0026#34;images/og-image.png\u0026#34; 接下来，根据主题中使用的插件不同，可能在data目录下也会有部分配置，这部分我不做讲解。\n此外，如果你想要修改主题的样式，可以在 assets 目录下进行修改。\n定制化你的文章 在 hugo 中，文章通过 hugo new 命令创建。\nhugo new posts/your-post-name.md 这样就创建了一篇文章，文章的内容在 content/posts/your-post-name.md 中。\n它会查看 archetypes 目录下的 default.md 文件，将其内容执行并复制到新建的文章中。\n下面是一个例子：\n--- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} draft: true --- 我将会另外写一篇文章讲解利用 hugo 的 archetypes 实现类似 hexo 的 abbrlink 功能。\n4 使用GitHub Pages部署免费博客 4.1 创建GitHub Pages 首先，我们需要创建一个仓库，仓库名必须为 username.github.io ，其中 username 为你的用户名。\n这样，GitHub Pages就会自动为你创建一个网站。\nNote\n现在GitHub Pages已经可以在所有仓库中创建了，但是我还是建议使用 username.github.io 的方式。\n因为这样可以不用自己申请域名。\n你可以在这里查看GitHub Pages配置情况 4.2 部署博客 首先，我们需要在本地生成静态文件。 hugo 这样就会在 public 目录下生成静态文件。 2. 接下来，我们需要设置远程仓库。\ncd public git init git remote add origin git pull origin master 最后，我们将静态文件推送到远程仓库。 git add . git commit -m \u0026#34;init\u0026#34; git push origin master 在 GitHub Pages 的设置中，将 Source 设置为 master branch 。 等待一段时间后，你的博客就会部署成功了。访问地址为 https://username.github.io 。 4.3 （可选）绑定域名 如果你想要绑定域名，可以在 GitHub Pages 的设置中，将 Custom domain 设置为你的域名。\n然后，在你的域名服务商中，添加一条 CNAME 记录，将 username.github.io 指向你的域名。 即可完成绑定。\n5 结语 至此，你的博客就已经部署成功了。\n不过它存在以下几点问题：\n操作繁琐，每次写完文章都需要手动执行一系列命令。 备份同步麻烦。 这些问题将会在我的下一篇博客中解决。\n在下一篇博客中，我将详细讲解利用GitHub Action自动部署的方案，这样你就只需在本地push整个目录，就可以自动部署了。\n"},{"section":"Blog","slug":"/blog/helloworld/","title":"Re:你好，世界","description":"hello world","date":"August 26, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech/blog/202308272034636.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"\"\n    width=\"420\" /\u003e\n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://cdn.hluvmiku.tech/blog/202308272034636.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"100\"\n    width=\"100\" /\u003e\n","searchKeyword":"","categories":"网站搭建, 技术分享, 生活","tags":"hello world","content":" 目录 原来的博客发生了什么？ 这是什么？ 封面是什么？ 总之，因祸得福 原来的博客发生了什么？ 长话短说，我不小心把之前博客的数据库删了。\n就单纯是一不小心删除了了数据库文件。\n这是什么？ 这是我用 Hugo 搭建的博客，并使用 Github Actions 自动部署。\n所有图片通过 七牛云 储存，本地上传采用了 PicGO。\n全博客本着能用现成的就不造轮子的宗旨。\n感觉比上一个博客舒服多了，具体流程我会在之后的文章中分享。\n封面是什么？ 封面是我无意中翻出去年自己设计的第一款鼠标垫的私货款式，因为不符合某些要求，最后没做出来。\n总之，因祸得福 这是我的第六版博客。\n自己手写了3版，第一版是Django乱做的，第二版是纯三件套搭的，第三版是用Vue3搭的。\n第四版，也就是之前的博客，是用Hexo搭的，部署在自己服务器上，但是被我手抖删除了。\n在这之后的半年里，我试着用wordpress搭建过博客，不尽如人意，然后我又用Vue3写了一个。\n但是我太懒了，感觉也没提升，就搁置了。\n现在的这一版，我放弃了自己手动搭博客，也懒得再在本地搭了。\n托管在GitHub上，用现成的框架，用OSS储存图片，如果不是因为我第四版博客崩了，我也绝对不会接受这套方案。\n现在感觉这套方案很好🥰。\n"}]